<section>
  <h2>Select Query</h2>
  <p>Select queries are used to select rows matching search conditions or join
  conditions from database. If the search conditions are not specified,
  <a href="#cartesian-product">Cartesian product</a> of all rows from the tables
  specified by <code>from()</code> will be returned.</p>
  <p>Scope of select queries MUST be evaluated using
  <a href="#select-scope-algorithm">select scope algorithm</a> before
  execution. The select queries implement the following interface:</p>
  <pre class="idl">
    interface ISelectQuery : IQuery {
      ISelectQuery from(ITable... tables);
      ISelectQuery where(ILogicalPredicate searchCondition);
      ISelectQuery innerJoin(ITable table, ILogicalPredicate joinCondition);
      ISelectQuery leftOuterJoin(ITable table, ILogicalPredicate joinCondition);
      ISelectQuery limit((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery skip((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery orderBy(IColumn column, optional Order order);
      ISelectQuery groupBy(IColumn... column);
    };
  </pre>
  <dl class="member">
    <dt><code>ISelectQuery from(ITable... tables);</code></dt>
    <dd>Specifies the scope of the select query. This function can only be
    called once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery where(ILogicalPredicate searchCondition);</code></dt>
    <dd>Specifies search condition. This function can only be
    called once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery innerJoin(ITable table, ILogicalPredicate joinCondition);</code></dt>
    <dd>Specifies explicit <a href="#inner-join">inner join</a>. This function
    can be called multiple times per query.</dd>
    <dt><code>ISelectQuery leftOuterJoin(ITable table, ILogicalPredicate joinCondition);</code></dt>
    <dd>Specifies <a href="#left-outer-join">left outer join</a>. This function
    can be called multiple times per query.</dd>
    <dt><code>ISelectQuery limit((unsigned long or IBindableValue) numberOfRows);</code></dt>
    <dd>Specifies maximum number of rows to return. If the number is
    <code>0</code>, the query is effectively an no-op. This function can only
    be called once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery skip((unsigned long or IBindableValue) numberOfRows);</code></dt>
    <dd>Specifies maximum number of rows to skip from returning. If the
    number is greater than total number of rows filtered, an empty array will
    be returned. This function can only be called once per query, otherwise 
    <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery orderBy(IColumn column, optional Order order);</code></dt>
    <dd>Specify how to sort the returning row. This function can be called
    multiple times per query. The invocation order of this function will affect
    the results of sorting, , see
    <a href="#sorting-algorithm">sorting algorithm</a>.</dd>
    <dt><code>ISelectQuery groupBy(IColumn... column);</code></dt>
    <dd>Specify how to group returning rows in aggregation, see
    <a href="#aggregation">aggregation</a> for more details. This function can
    only be called once per query, otherwise <a>SyntaxError</a> will be
    thrown.</dd>
  </dl>
  <p class="note">
    There is not a hard rule regarding the invocation order of
    <a>ISelectQuery</a> member functions. However, it is recommended that the
    functions are invoked in the order of their appearance order in the
    interface for better readability.
  </p>
  <section>
    <h2>Cartesian Product</h2>
    <p>The Cartesian product of two tables are defined in the following.</p>
    <ol>
      <li>Let T<sub>1</sub> and T<sub>2</sub> denote the tables involved in the
        Cartesian product, and the target is to have
        T<sub>1</sub> &times T<sub>2</sub>.</li>
      <li>Let R<sub>1</sub> = [R<sub>11</sub>, R<sub>12</sub>, R<sub>13</sub>,
        ..., R<sub>1M</sub>] denote the rows of T<sub>1</sub>.</li>
      <li>Let R<sub>2</sub> = [R<sub>21</sub>, R<sub>22</sub>, R<sub>23</sub>,
        ..., R<sub>2N</sub>] denote the rows of T<sub>2</sub>.</li>
      <li>Cartesian product of T<sub>1</sub> and T<sub>2</sub> are performed in
        two steps.</li>
      <ol>
        <li>Let R = R<sub>1</sub> &times; R<sub>2</sub>. This makes R looks like
          [[R<sub>11</sub>, R<sub>21</sub>], [R<sub>11</sub>, R<sub>22</sub>],
          ..., [R<sub>11</sub>, R<sub>2N</sub>], [R<sub>12</sub>,
          R<sub>21</sub>], ..., [R<sub>1M</sub>, R_1N]].</li>
        <li>Flatten all pairs in R as a row, where T<sub>1</sub>'s columns are
          expanded before T<sub>2</sub>'s columns. T<sub>1</sub>'s columns
          appear in the order of schema declaration, and the same rule applies
          to T<sub>2</sub>'s column.</li>
      </ol>
    </ol>
  </section>
  <section>
    <h2>Select Scope Algorithm</h2>
    <p>The scope of a select query is determined by the following algorithm.</p>
    <ol>
      <li>Let T<sub>1</sub> denote the set of tables specified by <code>from()</code></li>
      <li>If <code>innerJoin()</code></li>
        <ol>
          <li>Let T<sub>2</sub> denote the table specified by inner join</li>
          <li>Let S<sub>2</sub> denote the scope of the join condition</li>
          <li>If S<sub>2</sub> &nsub; (T<sub>1</sub> &cup; T<sub>2</sub>), throws <a>SyntaxError</a></li>
        </ol>
      <li>If <code>leftOuterJoin()</code></li>
        <ol>
          <li>Let T<sub>3</sub> denote the table specified by left outer join</li>
          <li>Let S<sub>3</sub> denote the scope of the join condition</li>
          <li>If S<sub>3</sub> &nsub; (T<sub>1</sub> &cup; T<sub>3</sub>), throws <a>SyntaxError</a></li>
        </ol>
      <li>Let T<sub>4</sub> denote <dfn>valid projection scope</dfn>:
      T<sub>1</sub> &cup; T<sub>2</sub> &cup; T<sub>3</sub></li>
      <li>If <code>where()</code></li>
        <ol>
          <li>Let S<sub>4</sub> denote the scope of search condition</li>
          <li>If S<sub>4</sub> &nsub; T<sub>4</sub>, throws <a>SyntaxError</a></li>
        </ol>
      <li>If any column in <code>orderBy()</code>, <code>groupBy()</code>,
      or the projection list passed in the constructor of <a>ISelectQuery</a>
      object is not in the valid projection scope, throw <a>SyntaxError</a>.</li>
    </ol>
  </section>
  <section>
    <h2>Sorting Algorithm</h2>
    <p>The sorting algorithm is represented in the pseudo JavaScript code
    below.</p>
    <pre><code class="highlight">
      var orderBySpecs;  // Array of orderBy() specs given in this query.
      filteredRows.sort(function(lhs, rhs) {
        for (var i = 0; i < orderBySpecs.length; ++i) {
          var spec = orderBySpecs[i];
          var col = spec.column;
          if (lhs[col] == rhs[col]) {
            continue;
          }
          if ((spec.order == 'asc' && lhs[col] < rhs[col]) ||
              (spec.order == 'desc' && lhs[col] > rhs[col])) {
            return -1;
          } else {
            return 1;
          }
        }
        return 0;
      });
    </code></pre>
  </section>
  <section>
    <h2>Inner Join</h2>
    <p>Inner joins create a new result table by combining column values of two
    tables involved in the join based upon the predicate given as join
    condition. Inner joins MAY be specified either implicitly through search
    conditions, or explicitly via <code>innerJoin()</code>. The following
    example demonstrates two equivalent inner join syntaxes:</p>
    <pre class="example highlight">
    {{include: inner_join.js}}
    </pre>

    <p>The results of inner join MUST be equivalent to the outcome of the
    following algorithm:</p>
    <ol>
      <li>Let T<sub>1</sub> and T<sub>2</sub> denote tables involved in the
        inner join.</li>
      <li>Let C denotes the <a href="#cartesian-product">Cartesian product</a>
      of T<sub>1</sub> and T<sub>2</sub>.</li>
      <li>For each row in C, evaluate the predicate provided as join
      condition. Return the rows whose evaluation is true.</li>
    </ol>
    <p class="note">Conceptually the inner join will create a new table.
    Implementation MAY NOT create actual table as long as the returned results
    are correct.</p>
  </section>
  <section>
    <h2>Left Outer Join</h2>
    <p>This specification supports only left outer join, which preserves the
    unmatched rows from the first (left) table, joining them with a
    <code>NULL</code> row in the shape of the second (right) table.
    The algorithm is described below:</p>
    <ol>
      <li>Let T<sub>l</sub> and T<sub>r</sub> denote the left and right table
        involved in the left-outer join. Let c<sub>l</sub> denote columns of
        T<sub>l</sub>, and c<sub>r</sub> for T<sub>r</sub>.</li>
      <li>Create an empty result row array R.</li>
      <li>For each row r in T<sub>l</sub></li>
        <ol>
          <li>Find matching rows set R<sub>m</sub> within T<sub>r</sub> so that
            for each r<sub>m</sub> in R the join condition is satisfied by the
            pair (r, r<sub>m</sub>).</li>
          <li>If R<sub>m</sub> is empty, push a row with columns T<sub>r</sub>
            and fill every column with <code>null</code>.</li>
          <li>For each r<sub>m</sub> in R<sub>m</sub>, push a new row with
            columns c<sub>l</sub> from r, followed by columns c<sub>r</sub> from
            r<sub>m</sub>.</li>
        </ol>
      </li>
      <li>Return result array R.</li>
    </ol>
  </section>
  <section>
    <h2>Aggregation</h2>
    <pre class="idl">
      interface IAggregateFunction {
        IColumn avg(IColumn col);
        IColumn count(optional IColumn col = null);
        IColumn geomean(IColumn col);
        IColumn max(IColumn col);
        IColumn min(IColumn col);
        IColumn stddev(IColumn col);
        IColumn sum(IColumn col);
        IColumn var(IColumn col);
      };
    </pre>
    <p>The <a>IColumn</a> objects returned by
    <a>IAggregateFunction</a> MUST NOT be convertible to <a>Column</a> objects.
    </p>
  </section>
  <section>
    <h2>Global Functions</h2>
    <pre class="idl">
      interface IDatabaseFunctionProvider : IAggregateFunction {
        IColumn distinct(IColumn... col);
        ILogicalPredicate not(ILogicalPredicate predicate);
      };
    </pre>
  </section>
</section>
