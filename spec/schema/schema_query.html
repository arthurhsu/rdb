<section>
  <h2>Schema Query</h2>
  <p>A database instance is created using schema queries. The schema of a
  database instance can also be altered via schema queries. Schema queries are
  run in the context of <a>transaction</a> and can be executed any time during
  the life time of the database.</p>
  <p>Any name used inside the schema not obeying
  <a href="#naming-rules">Naming Rules</a> will result in raising
  <a>InvalidSchemaError</a> during the execution of schema queries.</p>

  <section>
    <h2>Database-Level Schema Query</h2>
    <p>The <dfn>ISchemaQueryProvider</dfn> is the interface of manipulating
    database-level schema:</p>
    <pre class="idl">
      interface ISchemaQueryProvider {
        readonly attribute boolean supportTransactionalSchemaChange;
        IExecutionContext setVersion(unsigned short version);
        IExecutionContext setForeignKeyCheck(boolean value);
        IDatabaseSchema schema();
        ITableBuilder createTable(DOMString tableName);
        ITableChanger alterTable(DOMString tableName);
        IExecutionContext dropTable(DOMString tableName);
      };
    </pre>
    <dl class="attributes">
      <dt><code>boolean
      <dfn data-dfn-for="ISchemaQueryProvider">supportTransactionalSchemaChange</dfn>
      </code></dt>
      <dd>Indicates whether the implementation supports schema changes in a
      transaction. When returning <code>false</code>, the
      <a>IExecutionContext</a> resulted from <code>createTable()</code>,
      <code>alterTable()</code>, or <code>dropTable()</code> will immediately
      commit associated transaction when executed. This implies that these
      contexts cannot be run in explicit transactions. Implementations MAY
      throw <a>TransactionStateError</a> if such misusage happened.</dd>
    </dl>
    <dl class="methods">
      <dt><code>IExecutionContext
      <dfn data-dfn-for="ISchemaQueryProvider">setVersion</dfn>(unsigned short version);</code></dt>
      <dd>Sets the version number of the schema, MUST be run in the context of
      a <a>transaction</a>. The <code>version</code> MUST NOT be set to
      <code>0</code>, otherwise <a>InvalidSchemaError</a> will be raised.</dd>
      <dt><code>IExecutionContext
      <dfn data-dfn-for="ISchemaQueryProvider">setForeignKeyCheck</dfn>(boolean value);</code></dt>
      <dd>Enables or disables foreign key constraint enforcement within the
      transaction that the execution context returned by this function is in.
      The change will be effective only after this function is called, and will
      not affect previously executed queries in the containing transaction.
      Misuse of this function MAY cause broken data integrity.
      </dd>
      <dt><code>IDatabaseSchema
      <dfn data-dfn-for="ISchemaQueryProvider">schema</dfn>();</code></dt>
      <dd>Returns an <a>IDatabaseSchema</a> object for crafting data
      manipulation queries.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ISchemaQueryProvider">createTable</dfn>(DOMString tableName);</code></dt>
      <dd>Returns a <a href="#table-builder">table builder</a> for creating a
      new table.</dd>
      <dt><code>ITableChanger
      <dfn data-dfn-for="ISchemaQueryProvider">alterTable</dfn>(DOMString tableName);</code></dt>
      <dd>Returns a <a href="#table-changer">table changer</a> for altering an
      existing table. The table referred by <code>tableName</code> MUST already
      exist in the database, otherwise a <a>DataError</a> will be raised.</dd>
      <dt><code>IExecutionContext
      <dfn data-dfn-for="ISchemaQueryProvider">dropTable</dfn>(DOMString tableName);</code></dt>
      <dd>Removes a table and all its rows from database. The table referred by
      <code>name</code> MUST already exist in the database, otherwise a
      <a>DataError</a> will be raised.</dd>
    </dl>
  </section>

  <section>
    <h2>Database Schema</h2>
    <p><dfn>IDatabaseSchema</dfn> presents a database.</p>
    <pre class="idl">
      interface IDatabaseSchema {
        readonly attribute DOMString name;
        readonly attribute unsigned short version;
        ITable table(DOMString tableName);
      };
    </pre>
    <dl class="attributes">
      <dt><code>DOMString
      <dfn data-dfn-for="IDatabaseSchema">name</dfn></code></dt>
      <dd>Name of the database.</dd>
      <dt><code>unsigned short
      <dfn data-dfn-for="IDatabaseSchema">version</dfn></code></dt>
      <dd>Version of the database schema.</dd>
    </dl>
    <dl class="methods">
      <dt><code>ITable
      <dfn data-dfn-for="IDatabaseSchema">table</dfn>(DOMString tableName);</code></dt>
      <dd>Returns a read-only object that implements <a>ITable</a> interface,
      whose members are <a>IColumn</a> objects representing columns in the
      specified table. The table referred by <code>tableName</code> MUST
      already exist in the database, otherwise a <a>DataError</a> will be
      raised.</dd>
    </dl>
  </section>

  <section>
    <h2>Table Builder</h2>
    <p><dfn>ITableBuilder</dfn> is used to describe the new table that will be
    created, and MUST be used within the context of a <a>transaction</a>.</p>
    <pre class="idl">
      interface ITableBuilder : IExecutionContext {
        ITableBuilder column(DOMString name, ColumnType type, optional boolean notNull = false);
        ITableBuilder primaryKey(PrimaryKeyDefinition primaryKey);
        ITableBuilder foreignKey(ForeignKeySpec foreignKey);
        ITableBuilder index(DOMString name, IndexedColumnDefinition columns);
        ITableBuilder index(IndexSpec spec);
      };
    </pre>
    <p>All methods returns the same <a>ITableBuilder</a> object that
    they were called from to make cascade builder pattern possible. If any of
    the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times except <code>primaryKey</code>.</p>
    <dl class="methods">
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">column</dfn>(DOMString
      name, ColumnType type, optional boolean notNull = false);</code></dt>
      <dd>Adds a column to table. <code>name</code> MUST be unique within the
      containing table. <dfn>NOT NULL</dfn> means the column MUST NOT have a
      value of <code>undefined</code> or <code>null</code>. When
      <code>notNull</code> is set to <code>true</code>, the column is treated as
      <a>NOT NULL</a>.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">primaryKey</dfn>(PrimaryKeyDefinition
      primaryKey);</code></dt>
      <dd>Adds a primary key to table. This method MUST NOT be called multiple
      times.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">foreignKey</dfn>(ForeignKeySpec
      foreignKey);</code></dt>
      <dd>Adds a foreign key to table.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">index</dfn>(DOMString name,
      IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an index to table. The <code>name</code> is the name of the
      index, and it MUST be unique within the containing table.</dd>
      <dt><code>ITableBuilder index(IndexSpec spec)</code></dt>
      <dd>Adds an index to table, overloading form that provides finer control
      over the index itself.</dd>
    </dl>
  </section>

  <section>
    <h2>Index Specifications</h2>
    <p>Two major index specification styles are supported. The most complete
    one is dictionary type <dfn>IndexedSpec</dfn>.</p>
    <pre class="idl">
      typedef (DOMString or DOMString[] or IndexedColumnSpec[]) IndexedColumnDefinition;
      dictionary IndexSpec {
        DOMString name;
        IndexedColumnDefinition column;
        IndexType type = "btree";
        boolean unique = false;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the index, MUST be unique within the containing table.</dd>
      <dt><code>column</code></dt>
      <dd>Indexed column definitions. If provided as
          <code>DOMString</code>, the string MUST <a>refer</a> to an
          <a>indexable</a> column of the containing table; if provided as
          <code>DOMString[]</code>, it MUST NOT be empty, and the strings MUST
          <a>refer</a> to different <a>indexable</a> columns of the containing
          table. In these two cases, default sort order of <code>asc</code> is
          used. If provided as <code>IndexedColumnSpec[]</code>, it MUST NOT
          be empty, and each <code>IndexedColumnSpec</code> MUST <a>refer</a>
          to different column.</dd>
      <dt><code>type</code></dt>
      <dd>(Optional) Type of index, default to <code>btree</code></dd>
      <dt><code>unique</code></dt>
      <dd>(Optional) Keys in index shall be unique or not,
          default to <code>false</code>.</dd>
    </dl>
    <p>Index type allows user to hint the query engine to create an index on
    specified columns in given sorting orders. The query engine MAY construct
    the index, MAY follow the given sorting orders, and MAY use the specified
    type. The query engine can refuse to construct the index as specified, or
    construct a different index.</p>

    <p>The index type is an enum:</p>
    <pre class="idl">
      enum IndexType {
        // B+ Tree index.
        "btree",

        // Hash index.
        "hash",

        // Full text search.
        "fulltext"
      };
    </pre>

    <p>An index can be keyed by one or more columns. A <dfn>unique key</dfn>
    means that the value or combination of values used as index key is unique
    within the index. By default, all indices allow duplicate keys unless the
    <code>unique</code> is set to true. A <a>ConstraintError</a> will be thrown
    if user tried to insert/update a row with duplicated key when a unique
    index is specified.</p>

    <p>The WebIDL below defines indexed column specification.</p>
    <pre class="idl">
      dictionary IndexedColumnSpec {
        DOMString name;
        Order order = "asc";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the indexed column, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>order</code></dt>
      <dd>(Optional) Sorting order of the column, default to
          <code>asc</code>.</dd>
    </dl>
    <p>If an index definition overlapped with implicit indices created by
    constraints (for example, create an index on the same column of the primary
    key), it will be up to the query engine to determine whether or not to
    create this index.</p>
  </section>

  <section>
    <h2>Primary Key Specification</h2>
    <p>Primary key is a specialized unique index. Each table can have only one
    primary key. A primary key can be specified using unique index
    specification, or use the following WebIDL:</p>
    <pre class="idl">
      dictionary PrimaryKeySpec {
        DOMString name;
        IndexedColumnDefinition column;
        boolean autoIncrement = false;
      };

      typedef (IndexedColumnDefinition or PrimaryKeySpec) PrimaryKeyDefinition;
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt><dd>Name of primary key. If not specified, it
      will be named as <code>`PK_${tableName}`</code>.</dd>
      <dt><code>column</code></dt><dd>Columns that consists primary key, MUST
      <a>refer</a> to <a>indexable</a> columns of the containing table.</dd>
      <dt><code>autoIncrement</code></dt><dd>Create auto-increment
      primary key. When this is set to <code>true</code>, there MUST be only
      one column in the <code>column</code> field with <code>numeric</code>
      column type.</dd>
    </dl>
    <p>When the autoIncrement field is specified, the specified column MUST be
    of type <code>Number</code>. An auto-increment key will start from zero.
    When a new row is inserted into the table, the key will increase by one and
    assigned to that row regardless the original key value given to the
    row.</p>
    <p class="note">Unlike SQL, primary key MUST have name. Unnamed primary key
    will be automatically given a name.</p>
  </section>

  <section>
    <h2>Foreign Key Specification</h2>
    <p>The following WebIDL defines foreign key specification.</p>
    <pre class="idl">
      dictionary ForeignKeySpec {
        DOMString name;
        DOMString local;
        DOMString remote;
        ForeignKeyAction action = "restrict";
        ForeignKeyTiming timing = "immediate";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the foreign key, MUST be unique withing the containing table.
      </dd>
      <dt><code>local</code></dt>
      <dd>Referring column name, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>remote</code></dt>
      <dd>Referred column in its <a>full name</a>, MUST <a>refer</a> to an
      <a>indexable</a> column.</dd>
      <dt><code>action</code></dt>
      <dd>(Optional) Foreign key action, default to <code>restrict</code>.</dd>
      <dt><code>timing</code></dt>
      <dd>(Optional) Foreign key timing, default to <code>immediate</code>.
      </dd>
    </dl>
    <p>A <dfn>chainned foreign key</dfn> means the <code>remote</code> column
    is also a <code>local</code> column of another foreign key, which forms a
    dependency. The query engine MAY support chainned foreign key. The query
    engine MAY support referred column to be within the containing table.</p>

    <p>Foreign key actions are enum values as defined in the following:</p>
    <pre class="idl">
      enum ForeignKeyAction {
        // Any constraint violation results in cancelling the operation that
        // violated the constraint.
        "restrict",

        // Constraint violation results in modifying related tables as
        // necessary to maintain data integrity.
        "cascade"
      };
    </pre>
    <p>Foreign key timings are enum values as defined below:</p>
    <pre class="idl">
      enum ForeignKeyTiming {
        // The constraint is enforced right before a transaction is committed.
        // The constraint can be violated by individual queries during the
        // lifetime of the enclosing transaction, without any error being
        // thrown.
        "deferrable",

        // The constraint is enforced during execution of each individual query.
        "immediate"
      };
    </pre>
  </section>

  <section>
    <h2>Table Changer</h2>
    <p>Table changer is used to change the schema of an existing table, and
    MUST be used within the context of a <a>transaction</a>. If the table
    already contains data, altering table schema can cause constraint
    violations and fail the transaction.</p>
    <pre class="idl">
      interface ITableChanger : IExecutionContext {
        ITableChanger rename(DOMString newTableName);
        ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);
        ITableChanger dropColumn(DOMString name);
        ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);
        ITableChanger addForeignKey(ForeignKeySpec foreignKey);
        ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);
        ITableChanger dropConstraintOrIndex(DOMString name);
        IColumnChanger setColumn(DOMString name);
      };
    </pre>
    <p>All methods returns the same <code>ITableChanger</code> object that
    they were called from to make cascade builder pattern possible, except that
    <code>setColumn</code> will return a <a>IColumnChanger</a> instead. If any
    of the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times.</p>
    <dl class="methods">
      <dt><code>ITableChanger rename(DOMString newTableName);</code></dt>
      <dd>Renames the table, <code>newTableName</code> MUST be unique within the
      database, and MUST NOT be the same as existing table name.</dd>
      <dt><code>ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);</code></dt>
      <dd>Adds a new column to table, <code>name</code> MUST be unique within
      the containing table. If <code>defaultValue</code> is given, it MUST
      be of the same type as specified in <code>type</code>. Every existing row
      in the table will be added a new column with </code>defaultValue</code>.
      </dd>
      <dt><code>ITableChanger dropColumn(DOMString name);</code></dt>
      <dd>Removes a column from table. The <code>name</code> MUST <a>refer</a>
      to an existing column in the table schema. The referred column MUST NOT
      be the only column in the table schema, and MUST NOT be referred by any
      index nor constraints. Every existing row in the table will be modified
      to remove the field represented by that column.</dd>
      <dt><code>ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);</code></dt>
      <dd>Adds a primary key to table, the table MUST not have existing primary
      key.</dd>
      <dt><code>ITableChanger dropPrimaryKey();</code></dt>
      <dd>Removes primary key from table. If the table does not have primary
      key, this method will do nothing.</dd>
      <dt><code>ITableChanger addForeignKey(ForeignKeySpec foreignKey);</code></dt>
      <dd>Adds a foreign key to the table.</dd>
      <dt><code>ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an index to the table. The <code>name</code> is the name
      of the index and MUST be unique within the containing table.</dd>
      <dt><code>ITableChanger dropConstraintOrIndex(DOMString name);</code></dt>
      <dd>Removes a constraint or index in table by name. The <code>name</code>
      MUST refer to an existing constraint or index.</dd>
      <dt><code>IColumnChanger setColumn(DOMString name);</code></dt>
      <dd>Changes a column in the table, and the <code>name</code> MUST
      <a>refer</a> to an existing column in the table schema.</dd>
    </dl>
  </section>

  <section>
    <h2>Column Changer</h2>
    <pre class="idl">
      interface IColumnChanger {
        ITableChanger set(DOMString newColumnName, optional boolean notNull = true);
      };
    </pre>
    <dl class="methods">
      <dt><code>ITableChanger set(DOMString newColumnName, optional boolean notNull = true);</code></dt>
      <dd>Changes the column's name or <a>NOT NULL</a> property. The returned
      <code>ITableChanger</code> is the parent object that creates this object.
      </dd>
      <p class="note">Changing column data type is not supported by this spec.
      JavaScript is famous of tricky type conversions and it is unlikely to
      have conversion rules that covers every corner case.</p>
    </dl>
  </section>

  <section class="informative">
    <h2>Schema Query Examples</h2>
    <p>The following example demonstrates how to create a database schema.</p>
    <pre class="example highlight">
      {{include: create-by-api.js}}
    </pre>
    <p>The following example shows how to alter database schema during schema
    upgrade.</p>
    <pre class="example highlight">
      {{include: upgrade-db.js}}
    </pre>
  </section>
</section>
