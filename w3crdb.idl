typedef (ArrayBuffer or Boolean or Date or Number or String or Object) ValueType;
typedef (Boolean or Date or Number or String) IndexableType;

enum ColumnType {
  'ArrayBuffer',
  'Boolean',
  'Date',
  'Number',
  'String',
  'Object'
};

typedef (void or Object[]) TransactionResults

interface IExecutionContext {
  Promise<TransactionResults> commit();
};

interface IJournaledExecutionContext : IExecutionContext {
  Promise<void> rollback();
};

interface ITransaction : IJournaledExecutionContext {
  Promise<TransactionResults> begin();
  Promise<TransactionResults> attach((IQuery or IProcedure) query);
};

interface IQuery : IExecutionContext {
  Promise<string> explain();
  IQuery bind((ValueType... or ValueType[]) values);
  string toSql();
};

interface IProcedure : IExecutionContext {
  readonly string name;
  void add((IQuery... or IQuery[]) queries);
};


/**
 * Section 1: database
 *
 * var db;
 * navigator.db.open('foo').then(function(instance) {
 *   db = instance;
 * }, function(e) {
 *   // type of e is DOMException
 * });
 */
enum RelationalDatabaseStorageType {
  "persistent",
  "temporary"
};

dictionary OpenDatabaseOptions {
  storageType: RelationalDatabaseStorageType
};
 
interface IRelationalDatabase {
  Promise<IDatabaseInstance> open(string name, optional OpenDatabaseOptions opt);
  Promise<void> delete(string name);
  IDatabaseFunctionProvider fn;
};

partial interface Navigator {
  IRelationalDatabase db;
};

enum TransactionType {
  "readonly",
  "readwrite"
};

interface IDatabaseInstance : ISchemaQueryProvider, IDataQueryProvider {
  readonly string name;
  string observe(ISelectQuery query, function(Object[]) callbackFn);
  void unobserve(string observeKey);
  ITransaction createTransaction(TransactionType type);
  IProcedure createProcedure(string name, optional (IQuery... or IQuery[]) queries); 
  void close();
  Promise<Object> export();
  Promise<void> import(Object data);
};


/**
 * Section 2: Data Schema Definition
 * db.create(jsonSchema).exec().then(function() { ... });
 * // add new tables
 * var tx = db.createTransaction('readwrite');
 * var q1 = db.createTable('emp')
 *              .column('id', 'Number', true)
 *              .column('name', 'String', true)
 *              .column('deptId', 'String', true)
 *              .column('title', 'String')
 *              .primaryKey([{name: 'id', order: 'asc'}])
 *              .unique(['name'])
 *              .index('idx_Desc', [{name: 'desc', order: 'asc'}])
 *              .foreignKey({
 *                name: 'fk_DeptId',
 *                local: 'deptId',
 *                remote: 'Dept.id',
 *                action: 'restrict',
 *                timing: 'immediate'
 *              });
 * q1.attachTo(tx);
 * var q2 = db.alterTable('dept')
 *              .addColumn('desc', 'String');
 * tx.append(q2);
 * tx.commit().then(resolver, rejecter);
 */
dictionary ColumnSpec {
  string name;
  string type;
  boolean notNull;
};

enum Order {
  'asc',
  'ascending',
  'desc',
  'descending'
};

dictionary IndexedColumn {
  string name;
  Order order = 'asc';
};

dictionary IndexSpec {
  string name;
  (string or string[] or IndexedColumn[]) column;
};

enum ForeignKeyAction {
  'cascade',
  'restrict'
};

enum ForeignKeyTiming {
  'deferred',
  'immediate'
};

dictionary ForeignKeySpec {
  string name;
  string local;
  string remote;
  ForeignKeyAction action;
  ForeignKeyTiming timing;
};

dictionary Constraint {
  primaryKey: (string or string[] or IndexedColumn),
  unique: string[],
  foreignKey: ForeignKeySpec[]
};

dictionary TableSpec {
  string name;
  ColumnSpec[] column;
  Constraint constraint;
  IndexSpec[] index;
};

dictionary Schema {
  string name;
  TableSpec[] table;
};

interface IDatabaseSchema {
  readonly string name;
  Object table(string tableName);
};

interface ITable {
  readonly string name;
  ITable as(string alias);
};

interface IColumn : IPredicate, IAggregator {
  readonly string name;
  readonly ColumnType type;
  readonly boolean nullable;
  IColumn as(string alias);
};

interface ISchemaQueryProvider {
  Promise<Schema> exportSchema();
  IQuery create(Schema schema);
  IDatabaseSchema schema();
  ITableBuilder createTable();
  ITableChanger alterTable();
};

interface ITableBuilder : IQuery {
  ITableBuilder column(string name, ColumnType type, optional boolean notNull = true);
  ITableBuilder primaryKey((string or string[] or IndexedColumn[]) keySpec);
  ITableBuilder index(string name, (string or string[] or IndexedColumn[]) indexSpec);
  ITableBuilder unique((string or string[]) uniqueSpec);
  ITableBuilder foreignKey(ForeignKeySpec spec);
};

interface ITableChanger : IQuery {
  ITableChanger rename(string newTableName);
  ITableChanger addColumn(string name, ColumnType type, optional boolean notNull = true);
  ITableChanger dropColumn(string name);
  IColumnChanger setColumn(string name);
};

interface IColumnChanger {
  ITableChanger set(string newName, ColumnType newType, optional boolean notNull = true);
};


/**
 * Section 3: Data Manipulation
 */
interface IDataQueryProvider {
  ISelectQuery select(IColumn...);
  IInsertQuery insert();
  IInsertQuery insertOrReplace();
  IUpdateQuery update();
  IDeleteQuery delete(); 
};

interface ISelectQuery : IQuery {
  ISelectQuery from(ITable... tables);
  ISelectQuery where(IPredicate searchCondition);
  ISelectQuery innerJoin(ITable table, IPredicate onCondition);
  ISelectQuery leftOuterJoin(ITable table, IPredicate onCondition);
  ISelectQuery limit((number or IBindableValue) numberOfRows);
  ISelectQuery skip((number or IBindableValue) numberOfRows);
  ISelectQuery orderBy(IColumn column, Order order);
  ISelectQuery groupBy(IColumn... column);
};

interface IInsertQuery : IQuery {
  IInsertQuery into(ITable table);
  IInsertQuery values((Object[] or IBindableValue[]) rows);
};

interface IUpdateQuery : IQuery {
  IUpdateQuery set(IColumn column, ValueType value);
  IUpdateQuery where(IPredicate searchCondition);
};

interface IDeleteQuery : IQuery {
  IDeleteQuery from(ITable table);
  IDeleteQuery where(IPredicate searchCondition);
};

typedef (IndexableValueType or IBindableValue) ComparableValueType

interface IPredicate {
  IPredicate eq(ComparableValueType value);
  IPredicate neq(ComparableValueType value);
  IPredicate lt(ComparableValueType value);
  IPredicate lte(ComparableValueType value);
  IPredicate gt(ComparableValueType value);
  IPredicate gte(ComparableValueType value);
  IPredicate match((IBindableValue or RegExp) value);
  IPredicate between(ComparableValueType value, ComparableValueType value);
  IPredicate in((IndexableValueType[] or IBindableArray) values);
  IPredicate isNull();
  IPredicate isNotNull();
  IPredicate complement();
  IPredicate and(IPredicate... childPredicate);
  IPredicate or(IPredicate... childPredicate);
};

interface IDatabaseFunctionProvider : IAggregateFunction {
  IColumn distinct(IColumn... col);
};

interface IAggregateFunction {
  IColumn avg(IColumn col);
  IColumn count(optional IColumn col = null);
  IColumn geomean(IColumn col);
  IColumn max(IColumn col);
  IColumn min(IColumn col);
  IColumn stddev(IColumn col);
  IColumn sum(IColumn col);
  IColumn var(IColumn col);
};
