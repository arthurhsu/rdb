<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>Relational Database API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'ED',
        shortName: 'rdb',
        editors: [
          {
            name: 'Arthur Hsu',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          },
          {
            name: 'Demetrios Papadopoulos',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          }
        ],
        wg: 'Relational Database API Interest Group',
        wgURI: 'https://www.github.com/arthurhsu/rdb',
        edDraftURI: 'https://www.github.com/arthurhsu/rdb'
      };
    </script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <section id="abstract">
      <p>
      This document defines APIs and behaviors of a relational database. The
      capabilities of the defined relational database are comparable to a 
      subset of SQL-03 standard.
      </p>
    </section>

    <section id="sotd">
      <p>This document has not been submitted to anywhere yet.</p>
    </section>

<section class="informative">
  <h2>Introduction</h2>
  <p>Relational data manipulation for web apps has been in a difficult
  state for years. WebSQL has quite a few problems and is hence
  deprecated. IndexedDB, on the other hand, is an object database. In this
  document, we define a series of easy-to-use APIs that promote readable,
  maintainable, and performant code for apps needing relational data.</p>

  <p>The APIs proposed in this document are designed for small-scale relational
  data manipulation. The following example shows how to open a database.</p>
  <pre class="example highlight">
// Open database named 'hr'.
// If the named instance does not exist, create an empty database instance.
// Otherwise, open the existing database named 'hr'.
var db;

function connect() {
  return navigator.db.open('hr').then(function(instance) {
    db = instance;

    // version is a read-only number that is for reference only.
    if (db.version == 0) {
      // This is an empty database.
      return setUpNewDb();
    } else if (db.version < 2) {
      // Version is smaller than expected, perform upgrades.
      return upgradeDb();
    }
  });
}

function setUpNewDb() {
  var tx = db.createTransaction('readwrite');
  var q1 = db.createTable('Dept')
             .column(/* column_name */ 'id',
                     /* column_type */ 'String',
                     /* not_null */ true)
             .column('name', 'String', true)
             .column('desc', 'String')
             .primaryKey([{'name': 'id'}]);

  var q2 = db.createTable('Emp')
             .column('id', 'Number', true)
             .column('name', 'String', true)
             .column('deptId', 'String', true)
             .column('title', 'String')
             .primaryKey([{name: 'id', order: 'asc'}])
             .unique(['name'])
             .index('idx_Desc', [{name: 'desc', order: 'asc'}])
             .foreignKey({
               'name': 'fk_DeptId',
               'local': 'deptId',
               'remote': 'Dept.id',
               'action': 'restrict',
               'timing': 'immediate'
             });
  var q3 = db.setVersion(2);

  tx.append([q1, q2, q3]);
  return tx.commit();
}

function upgradeDb() {
  return db.alterTable('Dept').addColumn('desc', 'String').commit();
}

connect().then(function() {
  // Real work starts here.
});

  </pre>
  <p>Once the database is opened, queries can be performed.</p>
  <pre class="example highlight">
var db;
var d = db.schema().table('Dept');

function insertData() {
  var deptData = [
    {'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
    {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
    {'id': 'NADA', 'name': 'Non existing'},
    {'id': 'L', 'name': 'Leadership'}
  ];
  return db.insert().into(d).values(deptData).commit();
}

function updateData() {
  return db.update(d).set(d.desc, 'Master minds').where(d.id.eq('L')).commit();
}

function deleteData() {
  return db.delete().from(d).where(d.id.eq('NADA')).commit();
}

function selectData() {
  return db.select().from(d).commit();
}

insertData().then(function() {
  return updateData();
}).then(function() {
  return deleteData();
}).then(function() {
  return selectData();
}).then(function(rows) {
  // Expected returns:
  // [{'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
  //  {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
  //  {'id': 'L', 'name': 'Leadership', 'desc': 'Master minds'}]
  console.log(rows);
});

  </pre>

  <p>The proposed spec defines the behaviors of a database. A database consists
  of two parts: storage and query engine. Data is stored in the storage as
  rows, each row is a tuple of values, and the types of values are defined as
  columns. Same class of rows are grouped together as a table. The database
  has a concept named schema to define columns inside tables, and the relations
  among rows. Query engine is responsible for reading and writing rows from the
  storage, enforcing relations defined in the schema, and providing various
  functions to manipulate how the rows are read and written.</p>
</section>

    <section id="conformance"></section>

<section>
  <h2>Schema</h2>
  <section>
    <h2>Overview</h2>
    <p>A schema defines the storage structure of a relational database.
    A schema MUST have a name. The origin of the page and the schema name
    together uniquely identify a database instance during runtime.</p>

    <p>A schema has a referential version number associated with it. Version
    number is an integer greater than zero and can be freely assigned. It has
    no effect on identifying a database. It is provided for the convenience of
    developers to version their schema without extra table.</p>

    <p>A schema is structured in a hierachical way. A database schema contains
    one or more tables. A table contains one or more columns, zero or more
    indices, and zero or more constraints. The collection of columns in a table
    defines the fields carried by a row, which is the fundamental unit of data
    storage in relational database. Each column consists a name and an
    associated data type. The indices hint the database engine to build index
    structures so that subsequent queries can be acclerated. Index definitions
    MAY be honored if the database engine determined that they are necessary.
    The constraints define the relations of rows and ensures data integrity,
    and MUST be honored.</p>

    <p>The database schema is constructed via builder pattern APIs. Schema can
    be changed through schema queries within any <code>readwrite</code>
    transactions.</p>
  </section>

<section>
  <h2>Naming Rules</h2>
  <p>Names, also known as identifiers, are used to identify entities in schema,
  i.e. database, table, column, index, and constraint. All names used in the
  database schema MUST abide the following rules:</p>
  <ul>
    <li>Names are case sensitive</li>
    <li>A name MUST pass the following check:
        <code>/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)</code>
    </li>
    <li>A name MUST NOT conflict with properties and methods defined in
        <code>Object.prototype</code> and <a>ITable</a>.
    </li>
  </ul>
  <p class="note">Unlike SQL, names in RDB are case-sensitive.</p>
</section>

<section>
  <h2>Column Types</h2>
  <p>A table column MUST be associated with a given type. Valid types are
  defined in <a><dfn>ColumnType</dfn></a> enum:</p>
  <pre class="idl">
    enum ColumnType {
      "blob",
      "boolean",
      "date",
      "number",
      "string",
      "object"
    };

    typedef (ArrayBuffer or boolean or Date or number or DOMString or object) ValueType;
    typedef (boolean or Date or number or DOMString) IndexableValueType;
  </pre>

  <p><dfn data-dfn-for="ColumnType">blob</dfn> represents JavaScript
  <code>ArrayBuffer</code>, and <dfn data-dfn-for="ColumnType">date</dfn>
  refers to <code>Date</code> object.
  <dfn data-dfn-for="ColumnType">boolean</dfn>,
  <dfn data-dfn-for="ColumnType">number</dfn>,
  <dfn data-dfn-for="ColumnType">string</dfn> and
  <dfn data-dfn-for="ColumnType">object</dfn> correpond to the types of the same
  names in JavaScript.</p>
  <p>JavaScript types that can be used in a column is defined as
  <dfn>ValueType</dfn>. Only some value types are <dfn>indexable</dfn>,
  indicating that they can be compared, sorted, and used in indices and
  predicates. These types are defined as <dfn>IndexableValueType</dfn>.
  Non-indexable types, <a href="ColumnType#blob">blob</a> and
  <a href="ColumnType#object">object</a>, MUST NOT be used to
  create indices and predicates, except the
  <code>isNull()</code> and <code>isNotNull()</code> predicates.</p>
</section>

<section>
  <h2>Ordering</h2>
  <p>There are two sorting orders defined in the <a><dfn>Order</dfn></a>
  enum:</p>
  <pre class="idl">
    enum Order {
      "asc",
      "desc"
    };
  </pre>
  <p>The <dfn data-dfn-for="Order">asc</dfn> represents ascending sorting order,
  and is the default sorting order if none were provided. The
  <dfn data-dfn-for="Order">desc</dfn> represents descending sorting order.</p>

  <p>Ascending sort order is the natural sort order, which means that if two
  fields are ordered as <code>a, b</code>, then <code>(a <= b) === true</code>.
  Since <code>blob</code> and <code>object</code> types are not
  <a>indexable</a>, they cannot be compared and thus the orders have no effect
  for these two types.</p>
</section>

<section>
  <h2>Schema Query</h2>
  <p>A database instance is created using schema queries. The schema of a
  database instance can also be altered via schema queries. Schema queries are
  run in the context of <a>transaction</a> and can be executed any time during
  the life time of the database.</p>
  <p>Any name used inside the schema not obeying
  <a href="#naming-rules">Naming Rules</a> will result in raising
  <a>InvalidSchemaError</a> during the execution of schema queries.</p>

  <section>
    <h2>Database-Level Schema Query</h2>
    <p>The <dfn>ISchemaQueryProvider</dfn> is the interface of manipulating
    database-level schema:</p>
    <pre class="idl">
      interface ISchemaQueryProvider {
        readonly attribute boolean supportTransactionalSchemaChange;
        IExecutionContext setVersion(unsigned short version);
        IExecutionContext setForeignKeyCheck(boolean value);
        IDatabaseSchema schema();
        ITableBuilder createTable(DOMString tableName);
        ITableChanger alterTable(DOMString tableName);
        IExecutionContext dropTable(DOMString tableName);
      };
    </pre>
    <dl class="attributes">
      <dt><code>boolean
      <dfn data-dfn-for="ISchemaQueryProvider">supportTransactionalSchemaChange</dfn>
      </code></dt>
      <dd>Indicates whether the implementation supports schema changes in a
      transaction. When returning <code>false</code>, the
      <a>IExecutionContext</a> resulted from <code>createTable()</code>,
      <code>alterTable()</code>, or <code>dropTable()</code> will immediately
      commit associated transaction when executed. This implies that these
      contexts cannot be run in explicit transactions. Implementations MAY
      throw <a>TransactionStateError</a> if such misusage happened.</dd>
    </dl>
    <dl class="methods">
      <dt><code>IExecutionContext
      <dfn data-dfn-for="ISchemaQueryProvider">setVersion</dfn>(unsigned short version);</code></dt>
      <dd>Sets the version number of the schema, MUST be run in the context of
      a <a>transaction</a>. The <code>version</code> MUST NOT be set to
      <code>0</code>, otherwise <a>InvalidSchemaError</a> will be raised.</dd>
      <dt><code>IExecutionContext
      <dfn data-dfn-for="ISchemaQueryProvider">setForeignKeyCheck</dfn>(boolean value);</code></dt>
      <dd>Enables or disables foreign key constraint enforcement within the
      transaction that the execution context returned by this function is in.
      The change will be effective only after this function is called, and will
      not affect previously executed queries in the containing transaction.
      Misuse of this function MAY cause broken data integrity.
      </dd>
      <dt><code>IDatabaseSchema
      <dfn data-dfn-for="ISchemaQueryProvider">schema</dfn>();</code></dt>
      <dd>Returns an <a>IDatabaseSchema</a> object for crafting data
      manipulation queries.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ISchemaQueryProvider">createTable</dfn>(DOMString tableName);</code></dt>
      <dd>Returns a <a href="#table-builder">table builder</a> for creating a
      new table.</dd>
      <dt><code>ITableChanger
      <dfn data-dfn-for="ISchemaQueryProvider">alterTable</dfn>(DOMString tableName);</code></dt>
      <dd>Returns a <a href="#table-changer">table changer</a> for altering an
      existing table. The table referred by <code>tableName</code> MUST already
      exist in the database, otherwise a <a>DataError</a> will be raised.</dd>
      <dt><code>IExecutionContext
      <dfn data-dfn-for="ISchemaQueryProvider">dropTable</dfn>(DOMString tableName);</code></dt>
      <dd>Removes a table and all its rows from database. The table referred by
      <code>name</code> MUST already exist in the database, otherwise a
      <a>DataError</a> will be raised.</dd>
    </dl>
  </section>

  <section>
    <h2>Database Schema</h2>
    <p><dfn>IDatabaseSchema</dfn> presents a database.</p>
    <pre class="idl">
      interface IDatabaseSchema {
        readonly attribute DOMString name;
        readonly attribute unsigned short version;
        ITable table(DOMString tableName);
      };
    </pre>
    <dl class="attributes">
      <dt><code>DOMString
      <dfn data-dfn-for="IDatabaseSchema">name</dfn></code></dt>
      <dd>Name of the database.</dd>
      <dt><code>unsigned short
      <dfn data-dfn-for="IDatabaseSchema">version</dfn></code></dt>
      <dd>Version of the database schema.</dd>
    </dl>
    <dl class="methods">
      <dt><code>ITable
      <dfn data-dfn-for="IDatabaseSchema">table</dfn>(DOMString tableName);</code></dt>
      <dd>Returns a read-only object that implements <a>ITable</a> interface,
      whose members are <a>IColumn</a> objects representing columns in the
      specified table. The table referred by <code>tableName</code> MUST
      already exist in the database, otherwise a <a>DataError</a> will be
      raised.</dd>
    </dl>
  </section>

  <section>
    <h2>Table Builder</h2>
    <p><dfn>ITableBuilder</dfn> is used to describe the new table that will be
    created, and MUST be used within the context of a <a>transaction</a>.</p>
    <pre class="idl">
      interface ITableBuilder : IExecutionContext {
        ITableBuilder column(DOMString name, ColumnType type, optional boolean notNull = false);
        ITableBuilder primaryKey(PrimaryKeyDefinition primaryKey);
        ITableBuilder foreignKey(ForeignKeySpec foreignKey);
        ITableBuilder index(DOMString name, IndexedColumnDefinition columns);
        ITableBuilder index(IndexSpec spec);
      };
    </pre>
    <p>All methods returns the same <a>ITableBuilder</a> object that
    they were called from to make cascade builder pattern possible. If any of
    the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times except <code>primaryKey</code>.</p>
    <dl class="methods">
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">column</dfn>(DOMString
      name, ColumnType type, optional boolean notNull = false);</code></dt>
      <dd>Adds a column to table. <code>name</code> MUST be unique within the
      containing table. <dfn>NOT NULL</dfn> means the column MUST NOT have a
      value of <code>undefined</code> or <code>null</code>. When
      <code>notNull</code> is set to <code>true</code>, the column is treated as
      <a>NOT NULL</a>.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">primaryKey</dfn>(PrimaryKeyDefinition
      primaryKey);</code></dt>
      <dd>Adds a primary key to table. This method MUST NOT be called multiple
      times.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">foreignKey</dfn>(ForeignKeySpec
      foreignKey);</code></dt>
      <dd>Adds a foreign key to table.</dd>
      <dt><code>ITableBuilder
      <dfn data-dfn-for="ITableBuilder">index</dfn>(DOMString name,
      IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an index to table. The <code>name</code> is the name of the
      index, and it MUST be unique within the containing table.</dd>
      <dt><code>ITableBuilder index(IndexSpec spec)</code></dt>
      <dd>Adds an index to table, overloading form that provides finer control
      over the index itself.</dd>
    </dl>
  </section>

  <section>
    <h2>Index Specifications</h2>
    <p>Two major index specification styles are supported. The most complete
    one is dictionary type <dfn>IndexedSpec</dfn>.</p>
    <pre class="idl">
      typedef (DOMString or DOMString[] or IndexedColumnSpec[]) IndexedColumnDefinition;
      dictionary IndexSpec {
        DOMString name;
        IndexedColumnDefinition column;
        IndexType type = "btree";
        boolean unique = false;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the index, MUST be unique within the containing table.</dd>
      <dt><code>column</code></dt>
      <dd>Indexed column definitions. If provided as
          <code>DOMString</code>, the string MUST <a>refer</a> to an
          <a>indexable</a> column of the containing table; if provided as
          <code>DOMString[]</code>, it MUST NOT be empty, and the strings MUST
          <a>refer</a> to different <a>indexable</a> columns of the containing
          table. In these two cases, default sort order of <code>asc</code> is
          used. If provided as <code>IndexedColumnSpec[]</code>, it MUST NOT
          be empty, and each <code>IndexedColumnSpec</code> MUST <a>refer</a>
          to different column.</dd>
      <dt><code>type</code></dt>
      <dd>(Optional) Type of index, default to <code>btree</code></dd>
      <dt><code>unique</code></dt>
      <dd>(Optional) Keys in index shall be unique or not,
          default to <code>false</code>.</dd>
    </dl>
    <p>Index type allows user to hint the query engine to create an index on
    specified columns in given sorting orders. The query engine MAY construct
    the index, MAY follow the given sorting orders, and MAY use the specified
    type. The query engine can refuse to construct the index as specified, or
    construct a different index.</p>

    <p>The index type is an enum:</p>
    <pre class="idl">
      enum IndexType {
        // B+ Tree index.
        "btree",

        // Hash index.
        "hash",

        // Full text search.
        "fulltext"
      };
    </pre>

    <p>An index can be keyed by one or more columns. A <dfn>unique key</dfn>
    means that the value or combination of values used as index key is unique
    within the index. By default, all indices allow duplicate keys unless the
    <code>unique</code> is set to true. A <a>ConstraintError</a> will be thrown
    if user tried to insert/update a row with duplicated key when a unique
    index is specified.</p>

    <p>The WebIDL below defines indexed column specification.</p>
    <pre class="idl">
      dictionary IndexedColumnSpec {
        DOMString name;
        Order order = "asc";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the indexed column, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>order</code></dt>
      <dd>(Optional) Sorting order of the column, default to
          <code>asc</code>.</dd>
    </dl>
    <p>If an index definition overlapped with implicit indices created by
    constraints (for example, create an index on the same column of the primary
    key), it will be up to the query engine to determine whether or not to
    create this index.</p>
  </section>

  <section>
    <h2>Primary Key Specification</h2>
    <p>Primary key is a specialized unique index. Each table can have only one
    primary key. A primary key can be specified using unique index
    specification, or use the following WebIDL:</p>
    <pre class="idl">
      dictionary PrimaryKeySpec {
        DOMString name;
        IndexedColumnDefinition column;
        boolean autoIncrement = false;
      };

      typedef (IndexedColumnDefinition or PrimaryKeySpec) PrimaryKeyDefinition;
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt><dd>Name of primary key. If not specified, it
      will be named as <code>`PK_${tableName}`</code>.</dd>
      <dt><code>column</code></dt><dd>Columns that consists primary key, MUST
      <a>refer</a> to <a>indexable</a> columns of the containing table.</dd>
      <dt><code>autoIncrement</code></dt><dd>Create auto-increment
      primary key. When this is set to <code>true</code>, there MUST be only
      one column in the <code>column</code> field with <code>numeric</code>
      column type.</dd>
    </dl>
    <p>When the autoIncrement field is specified, the specified column MUST be
    of type <code>Number</code>. An auto-increment key will start from zero.
    When a new row is inserted into the table, the key will increase by one and
    assigned to that row regardless the original key value given to the
    row.</p>
    <p class="note">Unlike SQL, primary key MUST have name. Unnamed primary key
    will be automatically given a name.</p>
  </section>

  <section>
    <h2>Foreign Key Specification</h2>
    <p>The following WebIDL defines foreign key specification.</p>
    <pre class="idl">
      dictionary ForeignKeySpec {
        DOMString name;
        DOMString local;
        DOMString remote;
        ForeignKeyAction action = "restrict";
        ForeignKeyTiming timing = "immediate";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the foreign key, MUST be unique withing the containing table.
      </dd>
      <dt><code>local</code></dt>
      <dd>Referring column name, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>remote</code></dt>
      <dd>Referred column in its <a>full name</a>, MUST <a>refer</a> to an
      <a>indexable</a> column.</dd>
      <dt><code>action</code></dt>
      <dd>(Optional) Foreign key action, default to <code>restrict</code>.</dd>
      <dt><code>timing</code></dt>
      <dd>(Optional) Foreign key timing, default to <code>immediate</code>.
      </dd>
    </dl>
    <p>A <dfn>chainned foreign key</dfn> means the <code>remote</code> column
    is also a <code>local</code> column of another foreign key, which forms a
    dependency. The query engine MAY support chainned foreign key. The query
    engine MAY support referred column to be within the containing table.</p>

    <p>Foreign key actions are enum values as defined in the following:</p>
    <pre class="idl">
      enum ForeignKeyAction {
        // Any constraint violation results in cancelling the operation that
        // violated the constraint.
        "restrict",

        // Constraint violation results in modifying related tables as
        // necessary to maintain data integrity.
        "cascade"
      };
    </pre>
    <p>Foreign key timings are enum values as defined below:</p>
    <pre class="idl">
      enum ForeignKeyTiming {
        // The constraint is enforced right before a transaction is committed.
        // The constraint can be violated by individual queries during the
        // lifetime of the enclosing transaction, without any error being
        // thrown.
        "deferrable",

        // The constraint is enforced during execution of each individual query.
        "immediate"
      };
    </pre>
  </section>

  <section>
    <h2>Table Changer</h2>
    <p>Table changer is used to change the schema of an existing table, and
    MUST be used within the context of a <a>transaction</a>. If the table
    already contains data, altering table schema can cause constraint
    violations and fail the transaction.</p>
    <pre class="idl">
      interface ITableChanger : IExecutionContext {
        ITableChanger rename(DOMString newTableName);
        ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);
        ITableChanger dropColumn(DOMString name);
        ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);
        ITableChanger addForeignKey(ForeignKeySpec foreignKey);
        ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);
        ITableChanger dropConstraintOrIndex(DOMString name);
        IColumnChanger setColumn(DOMString name);
      };
    </pre>
    <p>All methods returns the same <code>ITableChanger</code> object that
    they were called from to make cascade builder pattern possible, except that
    <code>setColumn</code> will return a <a>IColumnChanger</a> instead. If any
    of the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times.</p>
    <dl class="methods">
      <dt><code>ITableChanger rename(DOMString newTableName);</code></dt>
      <dd>Renames the table, <code>newTableName</code> MUST be unique within the
      database, and MUST NOT be the same as existing table name.</dd>
      <dt><code>ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);</code></dt>
      <dd>Adds a new column to table, <code>name</code> MUST be unique within
      the containing table. If <code>defaultValue</code> is given, it MUST
      be of the same type as specified in <code>type</code>. Every existing row
      in the table will be added a new column with </code>defaultValue</code>.
      </dd>
      <dt><code>ITableChanger dropColumn(DOMString name);</code></dt>
      <dd>Removes a column from table. The <code>name</code> MUST <a>refer</a>
      to an existing column in the table schema. The referred column MUST NOT
      be the only column in the table schema, and MUST NOT be referred by any
      index nor constraints. Every existing row in the table will be modified
      to remove the field represented by that column.</dd>
      <dt><code>ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);</code></dt>
      <dd>Adds a primary key to table, the table MUST not have existing primary
      key.</dd>
      <dt><code>ITableChanger dropPrimaryKey();</code></dt>
      <dd>Removes primary key from table. If the table does not have primary
      key, this method will do nothing.</dd>
      <dt><code>ITableChanger addForeignKey(ForeignKeySpec foreignKey);</code></dt>
      <dd>Adds a foreign key to the table.</dd>
      <dt><code>ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an index to the table. The <code>name</code> is the name
      of the index and MUST be unique within the containing table.</dd>
      <dt><code>ITableChanger dropConstraintOrIndex(DOMString name);</code></dt>
      <dd>Removes a constraint or index in table by name. The <code>name</code>
      MUST refer to an existing constraint or index.</dd>
      <dt><code>IColumnChanger setColumn(DOMString name);</code></dt>
      <dd>Changes a column in the table, and the <code>name</code> MUST
      <a>refer</a> to an existing column in the table schema.</dd>
    </dl>
  </section>

  <section>
    <h2>Column Changer</h2>
    <pre class="idl">
      interface IColumnChanger {
        ITableChanger set(DOMString newColumnName, optional boolean notNull = true);
      };
    </pre>
    <dl class="methods">
      <dt><code>ITableChanger set(DOMString newColumnName, optional boolean notNull = true);</code></dt>
      <dd>Changes the column's name or <a>NOT NULL</a> property. The returned
      <code>ITableChanger</code> is the parent object that creates this object.
      </dd>
      <p class="note">Changing column data type is not supported by this spec.
      JavaScript is famous of tricky type conversions and it is unlikely to
      have conversion rules that covers every corner case.</p>
    </dl>
  </section>

  <section class="informative">
    <h2>Schema Query Examples</h2>
    <p>The following example demonstrates how to create a database schema.</p>
    <pre class="example highlight">
var db;
var tx = db.createTransaction('readwrite');
var q1 = db.createTable('Dept')
           .column(/* column_name */ 'id',
                   /* column_type */ 'string',
                   /* not_null */ true)
           .column('name', 'string', true)
           .primaryKey([{'name': 'id'}]);

var q2 = db.createTable('Emp')
           .column('id', 'number', true)
           .column('name', 'string', true)
           .column('deptId', 'string', true)
           .column('title', 'string')
           .primaryKey([{'name': 'id', 'order': 'asc'}])
           .index('idx_Desc', [{'name': 'desc', 'order': 'asc'}])
           .foreignKey({
             'name': 'fk_DeptId',
             'local': 'deptId',
             'remote': 'Dept.id',
             'action': 'restrict',
             'timing': 'immediate'
           });

tx.exec([q1, q2]).then(function() {
  // Table created, do something here.
});

    </pre>
    <p>The following example shows how to alter database schema during schema
    upgrade.</p>
    <pre class="example highlight">
var db;
var version = db.schema().version();

if (version < 2) {
  // Need DB upgrade.
  var tx = db.createTransaction('readwrite');
  var q1 = db.setVersion(2);
  var q2 = db.createTable('NewTable')
             .column('id', 'string', true)
             .column('name', 'string', true);
  var q3 = db.alterTable('Emp')
             .addColumn('location', 'string', true, 'LAX')
             .setColumn('title').set('title', true)  // Change to NOT NULL
             .addIndex('idx_location', 'location');
  var q4 = db.dropTable('Foo');
  tx.exec([q1, q2, q3, q4]).then(function() {
    // Update data after schema has changed.
  });
}

    </pre>
  </section>
</section>


</section>

<section>
  <h2>Database</h2>

<section>
  <h2>Overview</h2>
  <p>A database's origin is the same as the origin of the document or worker.
  Each origin has an associated set of databases.</p>

  <p class="note">The database origin is not affected by changes to
  <code>document.domain</code>.</p>

  <p>Every database has a predefined layout of the data structures persisted,
  which is called a <a href="#schema">schema</a>. The <em>database name</em>
  specified in schema identifies the database within a specific origin.
  The name MUST satisfy the <a href="#naming-rules">Naming Rules</a>, and stay
  constant for the lifetime of the database. Each database also has a version
  number for reference only.</p>

  <p>Databases have a <em>delete pending</em> flag which is used during
  deletion. When a database is requested to be deleted the flag is set to true
  and all attempts at opening the database are stalled until database is
  deleted.</p>

  <p>The act of opening a database creates a <a>connection</a>. There MAY
  be multiple connections to a given <code>persistent</code> database at any
  given time, where <code>temporary</code> database accepts only one connection.
  Each connection has a <em>closePending</em> flag which initially is set to
  false.</p>

  <p>When a connection is initially created it is in opened state. The
  connection can be closed through several means. If the connection is garbage
  collected or the execution context where the connection was created is destroyed
  (for example due to the user navigating away from that page), the connection
  is closed. The connection can also be closed explicitly via the API. When the
  connection is closed the closePending flag is always set to true regardless of its previous state.
  All uncommitted transactions associated with a connection that is marked close pending will be canceled.</p>

  <p>Users can create observers associated with a given database. Each
  observer consists of a select query. When the results of that select query
  change, the observer will be triggered. The change MAY come from other
  connections. When the connection associated with a registered observer is
  marked as close pending, the observer MUST be unregistered automatically.</p>
</section>

<section>
  <h2>Relational Database</h2>
  <p>The relational database is part of <code>Navigator</code> as defined in
  following WebIDL.</p>
  <pre class="idl">
    partial interface Navigator {
      readonly attribute IRelationalDatabase db;
    };
  </pre>

  <p>The relational database is defined by the following WebIDL.</p>
  <pre class="idl">
    interface IRelationalDatabase {
      readonly attribute IDatabaseFunctionProvider fn;

      Promise< DatabaseConnection > open(DOMString name, OpenDatabaseOptions? opt);
      Promise< void > drop(DOMString name);
    };
  </pre>
  <dl class="attributes">
    <dt><code>IDatabaseFunctionProvider fn</code></dt>
    <dd>Provides a namespace for <a href="#aggregation-functions">aggregation
    functions</a> that can be used in queries.</dd>
  </dl>
  <dl class="methods">
    <dt><code>Promise< DatabaseConnection > open(DOMString name, OpenDatabaseOptions? opt)</code></dt>
    <dd>Opens a database connection using provided name. If the database does
    not exist, create a new database instance and returns connection to it.
    If the database is marked delete pending, the promise will be rejected with
    <a>BlockingError</a>. If the <code>OpenDatabaseOptions</code> is not
    specified, a <code>persistent</code> database with the given name will be
    opened/created.</dd>
    <dt><code>Promise< void > drop()</code></dt>
    <dd>Deletes a database using provided <code>name</code>. This MUST follow
    the <a href="#delete-database-algorithm">delete database algorithm</a>. If
    the database does not exist, the returned promise will resolve immediately.
    If the database is marked delete pending, the promise will resolve
    immediately.</dd>
  </dl>

  <p>Open database options are specified as a dictionary object.</p>
  <pre class="idl">
    dictionary OpenDatabaseOptions {
      RDBStorageType storageType;
    };
  </pre>

  
  The <code>RDBStorageType</code> is an enum:
  <pre class="idl">
    enum RDBStorageType {
      // Data will be persisted in permanent storage.
      "persistent",

      // Data will be persisted in memory only.
      "temporary"
    };
  </pre>

  <p>When <code>storageType</code> is set to <code>temporary</code>, the
  relational database acts as in-memory cache of data and offers only the
  relational query capability. The <code>storageType</code> is fixed for the
  lifetime of returned database connection.</p>

  <section>
    <h2>Delete Database Algorithm</h2>
    <p>The delete database algorithm is performed in following steps:</p>
    <ol>
      <li>Marks this database as delete pending.</li>
      <li>Marks each connection to this database as close pending, which will
      effectively prevent new transactions from creating.</li>
      <li>Waits for all pending transactions to be cancelled.</li>
      <li>Closes all connections.</li>
      <li>Deletes the database.</li>
      <li>Resolves the promise.</li>
    </ol>
  </section>
</section>

<section>
  <h2>Connection</h2>
  <p>The database <dfn>connection</dfn> is the means by which the browser
  session and underlying database communicate with each other. The following
  is the main interface of a database connection:</p>

  <pre class="idl">
    interface IDatabaseConnection {
      ITransaction createTransaction(optional TransactionMode mode = "readonly");
      Promise< Error > close();
      IBindableValue bind(unsigned short index);
    };
  </pre>
  <dl class="methods">
    <dt><code>ITransaction createTransaction(optional TransactionMode mode = "readonly");</code></dt>
    <dd>Creates an explicit transaction. If the connection is marked as close
    pending, throws <a>BlockingError</a>.</dd>
    <dt><code>Promise< Error > close();</code></dt>
    <dd>Closes the connection. The connection will be marked as
    close pending immediately after this call, and no more new transaction
    can be created within this connection. It is a best efforts call and
    may resolve with error, or NULL if everything succeeded.</dd>
    <dt><code>IBindableValue bind(unsigned short index);</code></dt>
    <dd>Returns a bindable value that can be used in parameterized query.</dd>
  </dl>

  <p>The actual database connection returned from <code>Navigator</code> is a
  class object that implements four different interfaces.</p>
  <pre class="idl">
    interface DatabaseConnection : IDatabaseConnection {
      readonly attribute DOMString name;
    };
    DatabaseConnection implements IDatabaseObserver;
    DatabaseConnection implements IDataQueryProvider;
    DatabaseConnection implements ISchemaQueryProvider;
  </pre>
  <dl class="attributes">
    <dt><code>name</code></dt>
    <dd>Name of the database. It MUST be the same as the <code>name</code>
    field specified in schema.</dd>
  </dl>
  <p>The <a>ISchemaQueryProvider</a> provides
  <a href="#database-level-schema-query">database-level schema query</a> and
  allows creating or changing the database schema. The
  <a>IDataQueryProvider</a> provides APIs to construct
  <a href="#data-manipulation-query">data manipulation query</a> to be used
  to manipulate data within a transaction. The <a>IDatabaseObserver</a>
  provides change observation for the results of a select query, regardless
  the changes are from this connection or not.</p>
</section>

<section>
  <h2>Transaction</h2>
  <p>A <dfn>transaction</dfn> is an atomic unit of reading and writing data in
  a database. The term atomic means it is guaranteed that all operations inside
  this transaction to be committed as a whole, or none get committed.
  A committed transaction guarantees all data being written to storage.
  The operations inside a transaction are referred as queries. A
  <dfn>query</dfn> means an interaction with the database: data retrieval,
  data persistence, or change of schema.</p>

  <p>Transaction execution behavior is modeled as the following:</p>

  <pre class="idl">
    typedef (void or object[]) TransactionResults;

    interface IExecutionContext {
      Promise< TransactionResults > commit();
      Promise< void > rollback();
    };
  </pre>
  <dl class="methods">
    <dt><code>Promise< TransactionResults > commit();</code></dt>
    <dd>Runs <a href="#commit-algorithm">commit algorithm</a>.</dd>
    <dt><code>Promise< void > rollback();</code></dt>
    <dd>Runs <a href="#rollback-algorithm">rollback algorithm</a>.</dd>
  </dl>

  <p>All transactions are associated with a database connection, which is the
  <a>connection</a> that the transaction is created within. A transaction has
  a predetermined <em>mode</em> to indicate what access this transaction is
  asking for. The mode is set when the transaction is created and remains fixed
  for the life of the transaction. There are two transaction modes:</p>

  <pre class="idl">
    enum TransactionMode {
      // Transaction intends to read data/schema only.
      "readonly",

      // Transaction intends to read/write data and/or read/change schema.
      "readwrite"
    };
  </pre>

  <p>A transaction has a <dfn>scope</dfn> that determines the rows affected by
  this transaction. The scope is automatically calculated. The scope of a
  transaction MAY dynamically change during the lifetime of the transaction.
  </p>

  <p>A transaction can be created explicitly or implicitly. An explicit
  transaction is created directly from
  <code>IDatabaseConnection.createTransaction()</code>. An implicit transaction
  is created when the <a href="#commit-algorithm">commit algorithm</a> needs
  one. The explicit transaction is modeled as following:</p>

  <pre class="idl">
    interface ITransaction : IExecutionContext {
      Promise< void > begin();
      Promise< TransactionResults > exec(IExecutionContext[] queries);
      Promise< TransactionResults > attach(IExecutionContext query);
    };
  </pre>
  <dl class="methods">
    <dt><code>Promise< void > begin();</code></dt>
    <dd>Starts <em>sequence mode</em> execution. The transaction will be kept
    alive until <code>commit()</code> or <code>rollback()</code> of this
    transaction is triggered, or the transaction is timed out by implementation
    (which the implementation MUST throw <a>TimoutError</a> and reject any
    further calls on this transaction object).</dd>
    <dt><code>Promise< TransactionResults > exec(IExecutionContext[] queries);</code></dt>
    <dd>Starts <em>batch mode</em> execution and auto-commit.</dd>
    <dt><code>Promise< TransactionResults > attach(IExecutionContext query);</code></dt>
    <dd>Schedules a query to existing <em>sequence mode</em> execution. The
    promise will be resolved with the results when the query is executed.
    The query MUST NOT be an explicit transaction, i.e. <a>ITransaction</a>
    object.</dd>
  </dl>

  <p class="note">This specification does not support nested transactions.</p>

  <p>The lifetime of an explicit transaction is controlled by the user.
  There are two ways to start execution: <em>batch mode</em> and
  <em>sequence mode</em>. In batch mode, an explicit transaction is started
  with <code>exec(queriesArray)</code> and returns
  a result <code>Promise</code>. All queries will be executed sequentially in
  the order received, and the results of last query in the transaction are
  returned in the promise. In sequence mode, user calls <code>begin()</code> to
  start the transaction, calls <code>attach(query)</code> to attach a query to
  the transaction's execution context. The user can call <code>commit()</code>
  to indicate the end of transaction, and a final result <code>Promise</code>
  will be returned; or the user can call <code>rollback()</code> to abort the
  transaction, and all modifications done by previous attached queries will be
  discarded.</p>

  <p>When a transaction is committed or rolled back, it is said to be
  <em>finished</em>. A finished transaction MUST NOT be started nor rolled
  back. If a transaction's connection is lost before transaction being
  finished, the transaction is effectively rolled back and no change will be
  persisted.</p>

  <section>
    <h2>Commit Algorithm</h2>
    <p>An <a>IExecutionContext</a> can be obtained from <a>ITransaction</a>, or
    other classes such as <a>IQuery</a> or <a>ITableBuilder</a>. The execution
    context from <a>ITransaction</a> is a <em>bound context</em>, which means
    that it has an associated transaction. An execution context from sources
    other than <a>ITransaction</a> is an <em>unbound context</em>, which means
    that it does not have an associated transaction.</p>

    <p>The commit algorithm is described in following steps:</p>
    <ol>
      <li>If the execution context is a bound context, go to step 3.</li>
      <li>If the context can be carried out using <code>readonly</code>
      transaction mode, create a transaction using that mode; otherwise create
      a <code>readwrite</code> transaction. Associate the transaction with the
      execution context.</li>
      <li>If the associated transaction is marked as <em>pending finish</em>,
      throws <a>TransactionStateError</a>.
      <li>Mark the associated transaction as <em>pending finish</em>, which
      will prohibit the transaction from attaching more queries, or calling
      <code>rollback</code>.
      <li>Retrieves the result promise <code>R</code> of the last execution
      context in the associated transaction from query engine.</li>
      <li>If the transaction is already running in sequence mode, returns
      <code>R</code>.</li>
      <li>If the associated transaction is not started, notifies the query
      engine to execute it in batch mode, and returns <code>R</code>.</li>
      <li>When <code>R</code> resolves or rejects, mark transaction as
      <em>finished</em>.</li>
    </ol>
  </section>

  <section>
    <h2>Rollback Algorithm</h2>
    <p>The rollback algorithm is described in following steps:</p>
    <ol>
      <li>If the execution context is an unbound context, returns a resolved
      promise.</li>
      <li>If the associated tranaction is marked as <em>pending finish</em> or
      <em>finished</em>, throws <a>TransactionStateError</a>.</li>
      <li>If the associated transaction is not executed yet, mark the
      transaction as <em>finished</em> and returns a resolved promise.</li>
      <li>Marks the associated transaction as <em>finish pending</em>, and
      notifies query engine to rollback. Returns a promise.</li>
      <li>When the query engine rolled back the transaction, resolve promise;
      otherwise, reject promise with <a>IntegrityError</a>.</li>
    </ol>
  </section>

  <section>
    <h2>Transaction Snapshots</h2>
    <p>A <dfn>snapshot</dfn> of the database is the contents of all rows in the 
    database at the time when the snapshot is taken. At any given time, query
    engine MUST guarantee only one connection can create snapshot on a given 
    scope. Conceptually, each transaction operates on its own snapshot of
    database, and the snapshot is taken at the beginning of transaction. The
    beginning of transaction is determined by either calling
    <a>ITransaction.begin</a> or <a>ITransaction.exec</a> for explicit
    transactions, or <a>IExecutionContext.commit</a> for implicit
    transactions.</p>

    <p>All changes performed by queries inside the transaction will only be
    effective on that snapshot. The end of transaction is determined by
    resolution or rejection of the <code>Promise</code> returned from
    <a>ITransaction.exec</a> or <a>IExecutionContext.commit</a>. If the
    transaction is committed, i.e. resolution of <code>Promise</code>, the
    database MUST be updated to that snapshot. If the transaction is rolled
    back, i.e. rejection of <code>Promise</code>, the snapshot is discarded.</p>

    <p>The final data persisted on database is determined by the last
    transaction snapshot committed by the query engine. The transaction
    snapshots MAY come from other sessions other than current session.
    The query engine MUST guarantee only one snapshot can be persisted at a
    given time if there were multiple snapshots on a given scope. If there were
    multiple snapshots on a given scope, and one of them is persisted while
    the others are open, all the opened snapshots will be invalidated and their
    associated transactions must be rolled back.</p>

    <p class="note">It's up to the implementation to determine whether a table
    scope or a row scope to be used in transaction snapshots. The minimum
    requirement for this specification is to support table scope, i.e.
    different transactions MUST be able to operate on different tables
    simultaneously.</p>
  </section>
</section>

<section>
  <h2>Observers</h2>
  <p>Observers monitor row changes inside a database. If the results from
  registered query change due to data changes in the database, the callback in
  corresponding observer will be invoked. Observer management are performed
  via the following interface:</p>

  <pre class="idl">
    callback observerCallback = void ();

    interface IDatabaseObserver {
      DOMString observe(ISelectQuery query, observerCallback callbackFn);
      void unobserve(DOMString observerKey);
    };
  </pre>
  <dl class="methods">
    <dt><code>DOMString observe(ISelectQuery query, observerCallback callbackFn);</code></dt>
    <dd>Registers a select query for observation, returns a unique observer key
    within the connection.</dd>
    <dt><code>void unobserve(DOMString observerKey);</code></dt>
    <dd>Removes a registered observer in the connection.</dd>
  </dl>

  <p>Although observers are registered/unregistered via a database connection
  object, the changes they receive may come from other connections.
  The callback function is only a signal of query result change, and the users
  are responsible to re-execute observed query in a transaction if desired.
  Unlike trigger in relational databases, observers do not require
  implementations to execute the observed query.</p>

  <p class="note">
  The specification supports observations only for single select queries, not
  for <code>readonly</code> transactions.
  </p>
</section>


</section>

<section>
  <h2>Data Manipulation</h2>
  <p>Data manipulation of a database is carried out through transactions and
  the queries within. In this section, the APIs for constructing queries will
  be detailed. Due to the complexity, <a href="#data-selection">
  data selection</a> will be discussed in its own section.</p>

<section>
  <h2>Schema Representation</h2>
  <p>The fundamental part of data manipulation is to specify what to
  manipulate. In a relational database, this implies table and columns in the
  schema. The schema objects for data manipulation are acquired through
  <a>IDatabaseSchema</a> objects obtained from
  <a>ISchemaQueryProvider</a><code>.schema()</code> offered by
  <a>DatabaseConnection</a>.</p>

  <section>
    <h2>Table Representation</h2>
    <p>The table objects returned by <a>IDatabaseSchema</a><code>.table()</code>
    implements the <a>ITable</a> interface. These table objects MUST have
    properties with same names as columns of that table, and the properties are
    <a>Column</a> objects, see <a href="#column-representation">column
    representation</a> for more details.</p>

    <pre class="idl">
      interface ITable {
        ITable as(DOMString alias);
        DOMString getName();
        DOMString getAlias();
      };
    </pre>
    <dl class="methods">
      <dt><code>ITable as(DOMString alias)</code></dt>
      <dd>Creates an alias for the table, this is useful for self-join.</dd>
      <dt><code>DOMString getName()</code></dt>
      <dd>Returns table name.</dd>
      <dt><code>DOMString getAlias()</code></dt>
      <dd>Returns table alias. If no alias is defined for this table schema
      object, <code>null</code> is returned.</dd>
    </dl>

    <p class="note">It is a delibrate design to use <code>getName()</code>
    and <code>getAlias()</code> in <code>ITable</code>, because the string-based
    properties of <code>ITable</code> are <code>IColumn</code> objects. In
    order to create less name conflicts, the get functions are used.</p>
  </section>

  <section>
    <h2>Column Representation</h2>
    <p>Column representation objects have a base interface as defined in the
    following:</p>
    <pre class="idl">
      interface IColumn {
        readonly attribute DOMString name;
        readonly attribute ColumnType type;
        readonly attribute DOMString fullName;
        readonly attribute boolean nullable;
        IColumn as(DOMString alias);
      };
    </pre>
    <dl class="attributes">
      <dt><code>name</code></dt>
      <dd>The name of the column.</dd>
      <dt><code>type</code></dt>
      <dd>Data type of the column.</dd>
      <dt><code>fullName</code></dt>
      <dd>The <a>full name</a> of the column. When the containing table has
      alias, it will be <code>`${ITable#getAlias}.${IColumn.name}`</code>,
      otherwise <code>`${ITable#getName}.${IColumn.name}`</code>.</dd>
      <dt><code>nullable</code></dt>
      <dd>When <code>false</code>, the column is <a>NOT NULL</a></dd>
    </dl>
    <dl class="methods">
      <dt><code>IColumn as(DOMString alias);</code></dt>
      <dd>Creates an alias for the column. The alias will be honored in select
      queries only.</dd>
    </dl>

    <p>The objects also provide interfaces for creating predicates, therefore
    they are defined by the <a>Column</a> interface.</p>
    <pre class="idl">
      interface Column : IColumn {
      };
      Column implements IComparisonPredicate;
      Column implements ITruthPredicate;
    </pre>
  </section>
</section>

<section>
  <h2>Bindable Values</h2>
  <p>Bindable values provides flexibilities for determining the actual values
  to be used in queries at run-time. They serve as placeholders of values.
  Bindable values are typed as following:</p>
  <pre class="idl">
    interface IBindableValue {
      readonly attribute any value;
    };
  </pre>
  <p>Type check of bound value is performed by query engine before executing
  the query. To assign value to <a>IBindableValue</a>, caller MUST use
  <a>IQuery.bind</a> prior to query execution. A query with any unassigned
  <a>IBindableValue</a>, or any assigned <a>IBindableValue</a> with mismatched
  type, MUST be rejected with <a>BindingError</a> during its execution.</p>

  <p>The following example demonstrate how to perform parameterized query using
  data binding:</p>
  <pre class="example highlight">
var db;

var query;

function init() {
  var dept = db.schema().table('Department');

  var emp = db.schema().table('Employee');
  query = db.select(emp.name.as('ename'), dept.name)
            .from(dept, emp)
            .where(dept.id.eq(emp.deptId).and(
                   emp.id.eq(db.bind(0))));
}

function updateModel(employeeId) {
  query.bind(employeeId).commit().then(function(rows) {
    console.log(rows[0]['ename'], rows[0]['Department.name']);
  });
}

  </pre>
</section>

<section>
  <h2>Common Query Behaviors</h2>
  <p>Data manipulation queries are created from the <a>IDataQueryProvider</a>
  interface, which is implemented by the <a>DatabaseConnection</a> object.</p>

  <pre class="idl">
    interface IDataQueryProvider {
      ISelectQuery select(IColumn... columns);
      IInsertQuery insert();
      IInsertQuery insertOrReplace();
      IUpdateQuery update(ITable table);
      IDeleteQuery delete();
    };
  </pre>
  <dl class="methods">
    <dt><code>ISelectQuery select(IColumn... columns);</code></dt>
    <dd>Creates a <a href="#data-selection">select query</a> to retrieve data
    from database. The parameters of this function forms the
    <dfn>projection list</dfn> of the generated select query. If no column
    is given, then the projection list will contain all columns in the
    <a href="#select-scope-algorithm">select scope</a>.</dd>
    <dt><code>IInsertQuery insert();</code></dt>
    <dd>Creates an <a href="#insert-query">insert query</a> to insert data into
    database.</dd>
    <dt><code>IInsertQuery insertOrReplace();</code></dt>
    <dd>Similar to <a href="#insert-query">insert query</a>, but behaves
    differently for primary key conflicts.</dd>
    <dt><code>IUpdateQuery update(ITable table);</code></dt>
    <dd>Creates an <a href="#update-query">update query</a> to update existing
    data in the database.</dd>
    <dt><code>IDeleteQuery delete();</code></dt>
    <dd>Creates a <a href="#delete-query">delete query</a> to remove data from
    database.</dd>
  </dl>

  <p>All queries MUST inherit from this base query interface.</p>
  <pre class="idl">
    interface IQuery : IExecutionContext {
      Promise< DOMString > explain();
      IQuery bind(any... values);
      IQuery clone();
      DOMString toSql();
    };
  </pre>
  <dl class="methods">
    <dt><code>Promise< DOMString > explain();</code></dt>
    <dd>Explains how this query will be executed in transaction. The returned
    string representation will be implementation-dependent. The specification
    recommends implementations to return the query execution plan and other
    useful information for developers to do performance tuning of their
    queries.</dd>
    <dt><code>IQuery bind(any... values);</code></dt>
    <dd>Creates a clone of this query, assigns values to <a>IBindableValue</a>
    inside the cloned query, and returns the cloned query for execution.
    The order of values provided in the parameter of this function corresponds
    to the binding index provided in <a>IDatabaseConnection.bind</a>, i.e.
    the first parameter will be assigned to index 0, the second parameter to
    index 1, and so on. If the values provided cannot be assigned (e.g.
    obvious type mismatch), a <a>BindingError</a> MAY be thrown.</dd>
    <dt><code>IQuery clone();</code></dt>
    <dd>Creates a clone of this query with a new execution context. The
    returned query type will be the same as the original, for example,
    cloning an <a>ISelectQuery</a> will effectively return an
    <a>ISelectQuery</a>.</dd>
    <dt><code>DOMString toSql();</code></dt>
    <dd>Converts the query to equivalent SQL statements. The returned SQL
    string will also be implementation-dependent, or <code>null</code> if the
    implementation does not support this feature. The specification recommends
    SQL-03 standard for generating SQL statements.</dd>
  </dl>
</section>

<section>
  <h2>Insert Query</h2>
  <p>Insert queries are used to insert rows into tables. There are two
  variations of insert queries: <code>insert</code> and
  <code>insertOrReplace</code>. Both variations support the following
  interface:</p>

  <pre class="idl">
    interface IInsertQuery : IQuery {
      IInsertQuery into(ITable table);
      IInsertQuery values((object or object[] or IBindableValue) rows);
    };
  </pre>
  <dl class="methods">
    <dt><code>IInsertQuery into(ITable table);</code></dt>
    <dd>Specifies the target table to insert rows into. For
    <code>insertOrReplace</code>, the <code>table</code> MUST have a primary
    key, otherwise <a>IntegrityError</a> will be thrown.</dd>
    <dt><code>IInsertQuery values((object or object[] or IBindableValue) rows);</code></dt>
    <dd>Supplies the row(s) to be inserted. When given an <code>object</code>
    as parameter, or the bindable value resolved as an object, the object will
    act as a single row; otherwise, each element in the given array is treated
    as an individual row.</dd>
  </dl>
  <p>All methods of <a>IInsertQuery</a> returns the calling
  <code>IInsertQuery</code> object for cascade builder pattern. The methods MUST
  be called once and only once per query before its execution, otherwise
  <a>SyntaxError</a> MUST be raised.</p>

  <p>If an <a>IInsertQuery</a> object is created from <code>insert</code>,
  and a row with duplicated primary key is given, <a>ConstraintError</a>
  MUST be thrown if query engine detected integrity violation. On the other
  hand, if the <a>IInsertQuery</a> object is from <code>insertOrReplace</code>,
  the offended row MUST be silently replaced by the new row provided,
  effectively as removing the offended row and insert the offending row.</p>

  <p>If any of the inserted row causes integrity violation other than primary
  key, a <a>ConstraintError</a> MUST be thrown regardless.</p>

  <p>If any of the given rows does not exactly match the table schema of the
  table specified, <a>DataError</a> MUST be raised. Exact match means that each
  column specified in the table schema MUST appear as a property of any
  object provided as row.</a>

  <p class="note"><a>IBindableValue</a> can also resolve as an array of
  objects to provide multiple rows in one call.</p>
</section>

<section>
  <h2>Delete Query</h2>
  <p>Delete queries are used to delete rows in a table. The rows to be deleted
  are specified via <a href="#search-condition">Search Condition</a>. If the
  search condition is not provided, all rows in the table specified by
  <code>from()</code> will be deleted. The delete query implements the following
  interface:</p>

  <pre class="idl">
    interface IDeleteQuery : IQuery {
      IDeleteQuery from(ITable table);
      IDeleteQuery where(ILogicalPredicate searchCondition);
    };
  </pre>
  <dl class="methods">
    <dt><code>IDeleteQuery from(ITable table);</code></dt>
    <dd>Specifies the target table to delete rows from. This method MUST be
    called before execution, or <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>IDeleteQuery where(ILogicalPredicate searchCondition);</code></dt>
    <dd>Specifies the search condition for filtering rows.</dd>
  </dl>
  <p>All methods of <a>IDeleteQuery</a> returns the calling
  <code>IDeleteQuery</code> object for cascade builder pattern. The methods can
  only be called once per query, otherwise <a>SyntaxError</a> MUST be raised.
  </p>

  <p>If the table is empty, or the search condition returns no matching rows,
  the delete query will finish successfully without doing anything. If deleting
  rows cause data integrity violation (for example, deleting a row that is
  referred in a foreign key), a <a>ConstraintError</a> MUST be raised.</p>
</section>

<section>
  <h2>Search Condition</h2>
  <p>Search condition specifies how the query engine should search the rows for
  query. They are represented by logical predicates, will be evaluated for
  rows in the database during query execution, and returns <code>true</code> if
  the evaluated row is a match or <code>false</code> otherwise. Each
  logical predicate implicitly carries a <a>scope</a>, which defines the tables
  that the predicate shall be evaluated against. All rows in these tables will
  be evaluated. The query engine MAY apply speed up techniques to accelerate
  the evaluation, for example, using indices.</p>
  <p>Logical predicates are obtained from either comparison, truth, or logical
  predicates. Comparison and truth predicates are obtained from <a>IColumn</a>
  objects. Complement of predicate is provided by the <code>not</code>
  function in <a>IDatabaseFunctionProvider</a>.</p>
  <p>The comparison or truth predicates can only compare the column type of
  the column associated. An implicit <code>typeof</code> will be called against
  the provided value to get the value type. If the provided value type is not
  the same as the column type, a <a>TypeError</a> will be thrown.</p>
  <p class="note">
  This spec does not provide implicit type conversion. All types MUST be
  explicit.
  </p>

  <section>
    <h2>Comparison Predicate</h2>
    <p>The comparison predicates evaluates the relation between a column's value
    and the given target. They are defined by the following interface:</p>
    <pre class="idl">
      typedef (boolean or Date or number or DOMString) IndexableValueType;
      typedef (IndexableValueType or IBindableValue) ComparableValueType;

      interface IComparisonPredicate {
        ILogicalPredicate eq((ComparableValueType or IColumn) value);
        ILogicalPredicate neq((ComparableValueType or IColumn) value);
        ILogicalPredicate lt((ComparableValueType or IColumn) value);
        ILogicalPredicate lte((ComparableValueType or IColumn) value);
        ILogicalPredicate gt((ComparableValueType or IColumn) value);
        ILogicalPredicate gte((ComparableValueType or IColumn) value);
      };
    </pre>
    <dl class="methods">
      <dt><code>ILogicalPredicate eq:((ComparableValueType or IColumn) value);</code></dt>
      <dd>The associated column equals to value. Equality is evaluated using
      the rule of JavaScript <code>==</code> operator.</dd>
      <dt><code>ILogicalPredicate neq((ComparableValueType or IColumn) value);</code></dt>
      <dd>The associated column does not equal to value. Inequality is evaluated
      using the rule of JavaScript <code>!=</code> operator.</dd>
      <dt><code>ILogicalPredicate lt((ComparableValueType or IColumn) value);</code></dt>
      <dd>The associated column is smaller than value. Relation is evaluated
      using the rule of JavaScript <code>&lt;</code> operator.</dd>
      <dt><code>ILogicalPredicate lte((ComparableValueType or IColumn) value);</code></dt>
      <dd>The associated column is smaller than or equals to value. Relation is
      evaluated using the rule of JavaScript <code>&lt;=</code> operator.</dd>
      <dt><code>ILogicalPredicate gt((ComparableValueType or IColumn) value);</code></dt>
      <dd>The associated column is greater than value. Relation is evaluated
      using the rule of JavaScript <code>&gt;</code> operator.</dd>
      <dt><code>ILogicalPredicate lt((ComparableValueType or IColumn) value);</code></dt>
      <dd>The associated column is greater than or equals to value. Relation is
      evaluated using the rule of JavaScript <code>&gt;=</code> operator.</dd>
    </dl>
    <p>Giving <code>IColumn</code> as the parameter of
    <a>IComparisonPredicate</a> creates implicit <a href="#inner-join">inner
    join</a> syntax. The search condition given by this predicate MUST be
    evaluated as if given in the form of <code>innerJoin</code>. If the given
    <a>IColumn</a> is of different type other than the associated column of
    <a>IComparisonPredicate</a>, a <a>TypeError</a> MUST be thrown.</p>
  </section>

  <section>
    <h2>Truth Predicate</h2>
    <p>The truth predicates evaluate whether the given condition is true for the
    associated column or not. They are defined by the following interface:</p>
    <pre class="idl">
      interface ITruthPredicate {
        ILogicalPredicate match((IBindableValue or RegExp or DOMString) value);
        ILogicalPredicate between(ComparableValueType lhs, ComparableValueType rhs);
        ILogicalPredicate in((ComparableValueType[] or IBindableValue) values);
        ILogicalPredicate isNull();
        ILogicalPredicate isNotNull();
      };
    </pre>
    <dl class="methods">
      <dt><code>ILogicalPredicate match((IBindableValue or RegExp or DOMString) value);</code></dt>
      <dd>The associated column matches the regular expression or string
      provided. When <code>value</code> is provided as string, and the column
      is indexed using <code>fulltext</code> type, implementation MAY treat
      this predicate as a hint to perform full text search.</dd>
      <dt><code>ILogicalPredicate between(ComparableValueType lhs, ComparableValueType rhs);</code></dt>
      <dd>The associated column is within the range between lhs and rhs. The
      relation is evaluated using the rule of JavaScript <code>&lt;=</code> and
      <code>&gt;=</code>.</dd>
      <dt><code>ILogicalPredicate in((ComparableValueType[] or IBindableValue) values);</code></dt>
      <dd>The associated column equals to one of the value inside
      <code>values</code>. Equality is evaluated using the rule of JavaScript
      <code>==</code> operator.</dd>
      <dt><code>ILogicalPredicate isNull();</code></dt>
      <dd>The associated column is <code>null</code> or <code>undefined</code>.</dd>
      <dt><code>ILogicalPredicate isNotNull();</code></dt>
      <dd>The associated column is neither <code>null</code> nor
      <code>undefined</code>.</dd>
    </dl>

    <p class="note">Like SQL, empty string is not null.</p>
    <p class="note">
    This spec does not support constant expressions and therefore
    <a>IComparisonPredicate</a> and <a>ITruthPredicate</a> MUST be associated
    with an <a>IColumn</a> object.
    </p>
  </section>

  <section>
    <h2>Logical Predicate</h2>
    <p>Logical predicate is the representation of search condition. Logical
    predicates implement the following interface:</p>
    <pre class="idl">
      interface ILogicalPredicate {
        ILogicalPredicate and(ILogicalPredicate... childPredicate);
        ILogicalPredicate or(ILogicalPredicate... childPredicate);
        ILogicalPredicate clone();
      };
    </pre>
    <dl class="methods">
      <dt><code>ILogicalPredicate and(ILogicalPredicate... childPredicate);</code></dt>
      <dd>Logical <code>AND</code> of logical predicates. The returning logical
      predicate will evaluate to true if and only if all predicates in its
      parameter are evaluated true.</dd>
      <dt><code>ILogicalPredicate or(ILogicalPredicate... childPredicate);</code></dt>
      <dd>Logical <code>OR</code> of logical predicates. The returning logical
      predicate will evaluate to true if any of the predicates in its parameter
      is evaluated true.</dd>
      <dt><code>ILogicalPredicate clone();</code></dt>
      <dd>Clone the search condition, including the binding place holders.</dd>
    </dl>

    <p class="note">The <code>NOT</code> operation is provided by
    <code>IDatabaseFunctionProvider.not().</code></p>

    <p>The <dfn>predicate scope</dfn> is the union of all tables involved for
    creating the predicate. For example, <code>IColumn.eq()</code> creates an
    <a>ILogicalPredicate</a>, and scope of that predicate is the table
    associated with the creating <a>IColumn</a> object.</p>
  </section>

  <section>
    <h2>Complementing Predicates</h2>
    <p>The predicates can be complemented using a global function
    <code>not()</code>. The function is provided as following:</p>
    <pre class="idl">
      interface IDatabaseFunctionProvider : IAggregateFunction {
        ILogicalPredicate not(ILogicalPredicate predicate);
      };
    </pre>
    <dl class="methods">
      <dt><code>ILogicalPredicate not(ILogicalPredicate predicate);</code></dt>
      <dd>Complement the evaluation result of passed in predicate, i.e. returns
      <code>false</code> if the predicate evaluated true, and vice versa.</dd>
    </dl>
  </section>

  <section>
    <h2>Subqueries</h2>
    <p><a href="#data-selection">Select queries</a> that can be evaluated into
    <a>IndexableValueType</a> or <a>IndexableValueType</a><code>[]</code> can
    be used in predicates as <a>ComparableValueType</a> values. The evaluated
    type MUST be identical as the type requested by predicate. The query
    engine MUST evaluate these subqueries first and automatic bind the values
    into the main query.</p>
    <pre class="example highlight">
var db;

function getDepartmentsWithFounders() {
  var dept = db.schema().table('Department');

  var emp = db.schema().table('Employee');

  return db.select(dept.name)
           .from(dept)
           .where(dept.id.in(
               db.select(emp.deptId)
                 .from(emp)
                 .where(emp.id.lt(12))))
           .commit();
}

    </pre>
  </section>

</section>

<section>
  <h2>Update Query</h2>
  <p>Update queries updates the value of a column in all rows that matches the
  search condition. If the search condition is not provided, then the update
  will be applied to all rows of the table.</p>
  <pre class="idl">
    interface IUpdateQuery : IQuery {
      IUpdateQuery set(IColumn column, ValueType value);
      IUpdateQuery where(ILogicalPredicate searchCondition);
    };
  </pre>
  <dl class="methods">
    <dt><code>IUpdateQuery set(IColumn column, ValueType value);</code></dt>
    <dd>Set the column to specified value. If the value type is not the same
    as the column type, a <a>TypeError</a> will be thrown. If the updated value
    will result in integrity check failure, a <a>ConstraintError</a> will be
    thrown. This function can be called multiple times per query, but each
    column can only be used once, otherwise a <a>SyntaxError</a> will be
    thrown.</dd>
    <dt><code>IUpdateQuery where(ILogicalPredicate searchCondition);</code></dt>
    <dd>Specify the search condition of update. This function can only be called
    once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
  </dl>
</section>


</section>

<section>
  <h2>Data Selection</h2>
  <p>Data selection is done via select queries, which select rows matching
  search conditions or join conditions from database. If the search conditions
  are not specified, <a href="#cartesian-product">Cartesian product</a> of all
  rows from the tables specified by <code>from()</code> will be returned.</p>
  <p>Scope of select queries MUST be evaluated using
  <a href="#select-scope-algorithm">select scope algorithm</a> before
  execution. The select queries implement the following interface:</p>
  <pre class="idl">
    interface ISelectQuery : IQuery {
      ISelectQuery from(ITable... tables);
      ISelectQuery where(ILogicalPredicate searchCondition);
      ISelectQuery innerJoin(ITable table, ILogicalPredicate joinCondition);
      ISelectQuery leftOuterJoin(ITable table, ILogicalPredicate joinCondition);
      ISelectQuery limit((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery skip((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery orderBy(IColumn column, optional Order order);
      ISelectQuery groupBy(IColumn... column);
      ISelectQuery union(ISelectQuery... query);
      ISelectQuery intersect(ISelectQuery... query);
      ISelectQuery except(ISelectQuery... query);
    };
  </pre>
  <dl class="member">
    <dt><code>ISelectQuery from(ITable... tables);</code></dt>
    <dd>Specifies the scope of the select query. This function can only be
    called once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery where(ILogicalPredicate searchCondition);</code></dt>
    <dd>Specifies search condition. This function can only be
    called once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery innerJoin(ITable table, ILogicalPredicate joinCondition);</code></dt>
    <dd>Specifies explicit <a href="#inner-join">inner join</a>. This function
    can be called multiple times per query.</dd>
    <dt><code>ISelectQuery leftOuterJoin(ITable table, ILogicalPredicate joinCondition);</code></dt>
    <dd>Specifies <a href="#left-outer-join">left outer join</a>. This function
    can be called multiple times per query.</dd>
    <dt><code>ISelectQuery limit((unsigned long or IBindableValue) numberOfRows);</code></dt>
    <dd>Specifies maximum number of rows to return. If the number is
    <code>0</code>, the query is effectively an no-op. This function can only
    be called once per query, otherwise <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery skip((unsigned long or IBindableValue) numberOfRows);</code></dt>
    <dd>Specifies maximum number of rows to skip from returning. If the
    number is greater than total number of rows filtered, an empty array will
    be returned. This function can only be called once per query, otherwise 
    <a>SyntaxError</a> will be thrown.</dd>
    <dt><code>ISelectQuery orderBy(IColumn column, optional Order order);</code></dt>
    <dd>Specify how to sort the returning row. This function can be called
    multiple times per query. The invocation order of this function will affect
    the results of sorting, , see
    <a href="#sorting-algorithm">sorting algorithm</a>.</dd>
    <dt><code>ISelectQuery groupBy(IColumn... column);</code></dt>
    <dd>Specify how to group returning rows in aggregation, see
    <a href="#aggregation">aggregation</a> for more details. This function can
    only be called once per query, otherwise <a>SyntaxError</a> will be
    thrown. Caller MUST provide one or more columns in the parameter, otherwise
    <a>SyntaxError</a> will be thrown. If the same column is provided twice
    in the parameters, it will be treated as provided only once.</dd>
    <dt><code>ISelectQuery union(ISelectQuery... query);</code></dt>
    <dd>Combine results of two or more select queries into a single result set
    that includes all the rows that belong to all queries in the union. See
    <a href="#union-projection">union projection</a> for details.</dd>
    <dt><code>ISelectQuery intersect(ISelectQuery... query);</code></dt>
    <dd>See <a href="intersect-and-except">intersect and except</a>.</dd>
    <dt><code>ISelectQuery except(ISelectQuery... query);</code></dt>
    <dd>See <a href="intersect-and-except">intersect and except</a>.</dd>
  </dl>
  <p class="note">
    There is not a hard rule regarding the invocation order of
    <a>ISelectQuery</a> member functions. However, it is recommended that the
    functions are invoked in the order of their appearance order in the
    interface for better readability.
  </p>

<section>
  <h2>Cartesian Product</h2>
  <p>The Cartesian product of two tables is calculated using the following
  algorithm.</p>
  <ol>
    <li>Let T<sub>1</sub> and T<sub>2</sub> denote the tables involved in the
      Cartesian product, and the target is to have
      T<sub>1</sub> &times T<sub>2</sub>.</li>
    <li>Let R<sub>1</sub> = [R<sub>11</sub>, R<sub>12</sub>, R<sub>13</sub>,
      ..., R<sub>1M</sub>] denote the rows of T<sub>1</sub>.</li>
    <li>Let R<sub>2</sub> = [R<sub>21</sub>, R<sub>22</sub>, R<sub>23</sub>,
      ..., R<sub>2N</sub>] denote the rows of T<sub>2</sub>.</li>
    <li>Cartesian product of T<sub>1</sub> and T<sub>2</sub> are performed in
      two steps.</li>
    <ol>
      <li>Let R = R<sub>1</sub> &times; R<sub>2</sub>. This makes R looks like
        [[R<sub>11</sub>, R<sub>21</sub>], [R<sub>11</sub>, R<sub>22</sub>],
        ..., [R<sub>11</sub>, R<sub>2N</sub>], [R<sub>12</sub>,
        R<sub>21</sub>], ..., [R<sub>1M</sub>, R<sub>1N</sub>]].</li>
      <li>Flatten all pairs in R as a row, where T<sub>1</sub>'s columns are
        expanded before T<sub>2</sub>'s columns. T<sub>1</sub>'s columns
        appear in the order of schema declaration, and the same rule applies
        to T<sub>2</sub>'s column.</li>
    </ol>
  </ol>
</section>

<section>
  <h2>Select Scope Algorithm</h2>
  <p>The scope of a select query is determined by the following algorithm.</p>
  <ol>
    <li>Let T<sub>1</sub> denote the set of tables specified by <code>from()</code></li>
    <li>If <code>innerJoin()</code> existed in query:</li>
      <ol>
        <li>Let T<sub>2</sub> denote the table specified by inner join</li>
        <li>Let S<sub>2</sub> denote the scope of the join condition</li>
        <li>If S<sub>2</sub> &nsub; (T<sub>1</sub> &cup; T<sub>2</sub>), throws <a>SyntaxError</a></li>
      </ol>
    <li>If <code>leftOuterJoin()</code> existed in query:</li>
      <ol>
        <li>Let T<sub>3</sub> denote the table specified by left outer join</li>
        <li>Let S<sub>3</sub> denote the scope of the join condition</li>
        <li>If S<sub>3</sub> &nsub; (T<sub>1</sub> &cup; T<sub>3</sub>), throws <a>SyntaxError</a></li>
      </ol>
    <li>Let T<sub>4</sub> denote <dfn>valid projection scope</dfn>:
    T<sub>1</sub> &cup; T<sub>2</sub> &cup; T<sub>3</sub></li>
    <li>If <code>where()</code> existed in query:</li>
      <ol>
        <li>Let S<sub>4</sub> denote the scope of search condition</li>
        <li>If S<sub>4</sub> &nsub; T<sub>4</sub>, throws <a>SyntaxError</a></li>
      </ol>
    <li>If any column in <code>orderBy()</code>, <code>groupBy()</code>,
    or the projection list passed in the constructor of <a>ISelectQuery</a>
    object is not in the valid projection scope, throw <a>SyntaxError</a>.</li>
  </ol>
</section>

<section>
  <h2>Sorting Algorithm</h2>
  <p>The sorting algorithm is represented in the pseudo JavaScript code
  below.</p>
  <pre><code class="highlight">
    var orderBySpecs;  // Array of orderBy() specs given in this query.
    filteredRows.sort(function(lhs, rhs) {
      for (var i = 0; i < orderBySpecs.length; ++i) {
        var spec = orderBySpecs[i];
        var col = spec.column;
        if (lhs[col] == rhs[col]) {
          continue;
        }
        if ((spec.order == 'asc' && lhs[col] < rhs[col]) ||
            (spec.order == 'desc' && lhs[col] > rhs[col])) {
          return -1;
        } else {
          return 1;
        }
      }
      return 0;
    });
  </code></pre>
</section>

<section>
  <h2>Inner Join</h2>
  <p>Inner joins create a new result table by combining column values of two
  tables involved in the join based upon the predicate given as join
  condition. Inner joins MAY be specified either implicitly through search
  conditions, or explicitly via <code>innerJoin()</code>. The following
  example demonstrates two equivalent inner join syntaxes:</p>
  <pre class="example highlight">
var db;

var tableA;

var tableB;

// Implicit inner join.
var q1 =
  db.select(tableA['key'], tableA['value'], tableB['timestamp'])
    .from(tableA, tableB)
    .where(tableA['key'].eq(tableB['key']));

// Explicit inner join.
var q2 =
  db.select(tableA['key'], tableA['value'], tableB['timestamp'])
    .from(tableA)
    .innerJoin(tableB, tableA['key'].eq(tableB['key']));

  </pre>

  <p>The results of inner join MUST be equivalent to the outcome of the
  following algorithm:</p>
  <ol>
    <li>Let T<sub>1</sub> and T<sub>2</sub> denote tables involved in the
      inner join.</li>
    <li>Let C denotes the <a href="#cartesian-product">Cartesian product</a>
    of T<sub>1</sub> and T<sub>2</sub>.</li>
    <li>For each row in C, evaluate the predicate provided as join
    condition. Return the rows whose evaluation is true.</li>
  </ol>
  <p class="note">Conceptually the inner join will create a new table.
  Implementation MAY NOT create actual table as long as the returned results
  are correct.</p>

  <p>The user is not allowed to mix implicit and explicit join. Implementations
  will throw either <a>SyntaxError</a> or <a>RuntimeError</a> for invalid
  queries violating this rule.</p>
</section>

<section>
  <h2>Left Outer Join</h2>
  <p>This specification supports only left outer join, which preserves the
  unmatched rows from the first (left) table, joining them with a
  <code>NULL</code> row in the shape of the second (right) table.
  The algorithm is described below:</p>
  <ol>
    <li>Let T<sub>l</sub> and T<sub>r</sub> denote the left and right table
      involved in the left-outer join. Let c<sub>l</sub> denote columns of
      T<sub>l</sub>, and c<sub>r</sub> for T<sub>r</sub>.</li>
    <li>Create an empty result row array R.</li>
    <li>For each row r in T<sub>l</sub></li>
      <ol>
        <li>Find matching rows set R<sub>m</sub> within T<sub>r</sub> so that
          for each r<sub>m</sub> in R the join condition is satisfied by the
          pair (r, r<sub>m</sub>).</li>
        <li>If R<sub>m</sub> is empty, push a row with columns T<sub>r</sub>
          and fill every column with <code>null</code>.</li>
        <li>For each r<sub>m</sub> in R<sub>m</sub>, push a new row with
          columns c<sub>l</sub> from r, followed by columns c<sub>r</sub> from
          r<sub>m</sub>.</li>
      </ol>
    </li>
    <li>Return result array R.</li>
  </ol>
</section>

<section>
  <h2>Aggregation</h2>
  <p>Aggregation is a special data selection performed via
  <a>ISelectQuery.groupBy</a> function. The aggregation functions supported are
  defined in the following.</p>
  <pre class="idl">
    interface IAggregateFunction {
      IColumn avg(IColumn col);
      IColumn count(optional IColumn col = null);
      IColumn distinct(IColumn... col);
      IColumn max(IColumn col);
      IColumn min(IColumn col);
      IColumn stddev(IColumn col);
      IColumn sum(IColumn col);
      IColumn var(IColumn col);
    };
  </pre>
  <dl class="methods">
    <dt><code>IColumn avg(IColumn col);</code></dt>
    <dd>Calculate the arithematic average of non-null values of column
    <code>col</code> for all rows grouped. If there are no rows with non-null
    values, or the column is not typed as <code>number</code>, returns
    <code>0</code>. The returned column is always typed as
    <code>number</code>.</dd>
    <dt><code>IColumn count(IColumn col);</code></dt>
    <dd>Count the number of rows. If <code>col</code> is NOT <code>null</code>,
    returns number of rows in the group whose <code>col</code> is not null,
    otherwise returns the total number of rows in the group.</dd>
    <dt><code>IColumn distinct(IColumn... col);</code></dt>
    <dd>Returns distinct value tuples of the specified columns in all grouped
    rows. <code>null</code> is considered as a unique value.</dd>
    <dt><code>IColumn max(IColumn col);</code></dt>
    <dd>Returns the maximum value of the column <code>col</code> for all rows
    grouped. The maximum value is determined by the last value of the
    <code>orderBy()</code> performed on that column. The <code>max()</code>
    function returns <code>null</code> if and only if all values grouped are
    <code>null</code>.</dd>
    <dt><code>IColumn min(IColumn col);</code></dt>
    <dd>Returns the minimum value of the column <code>col</code> for all rows
    grouped. The minimum value is determined by the first value of the
    <code>orderBy()</code> performed on that column. The <code>max()</code>
    function returns <code>null</code> if and only if all values grouped are
    <code>null</code>.</dd>
    <dt><code>IColumn stddev(IColumn col);</code></dt>
    <dd>Similar to <code>avg()</code>, but returns standard deviation.</dd>
    <dt><code>IColumn sum(IColumn col);</code></dt>
    <dd>Calculate the arithematic sum of non-null values of column
    <code>col</code> for all rows grouped. If there are no non-null rows, or
    the column is not typed as <code>number</code>, returns <code>null</code>.
    The returned column is always typed as <code>number</code>.</dd>
    <dt><code>IColumn var(IColumn col);</code></dt>
    <dd>Similar to <code>avg()</code>, but returns statistical variance.</dd>
  </dl>
  <p>The <a>IColumn</a> objects returned by
  <a>IAggregateFunction</a> MUST NOT be convertible to <a>Column</a> objects.
  </p>
  <section>
  <h2>Limitations of Grouping</h2>
  <p>Aggregation can only happen on a single table. If the select scope
  contains more than one table, a <a>SyntaxError</a> will be thrown.</p>
  <p>The aggregation can happen for the given table without a
  <code>groupBy()</code> function, which implies grouping on all rows of that
  table.</p>
  <p>If the <code>groupBy()</code> is present, the <a>projection list</a> MUST
  consist of either the columns in projection list, or aggregation functions.
  The parameters of aggregation functions MUST be either <code>undefined</code>
  if allowed by signature, or from the columns provided as
  <code>groupBy()</code> parameters.</p>
  <p>If grouping and search conditions are both provided, search conditions
  will be evaluated first, and grouping will be operated on top of the filtered
  rows.</p>
  <p class="note">Aggregation by expression is not supported.</p>
  </section>
</section>

<section>
  <h2>Union Projection</h2>
  <p>Union projection is different from joins. It just attempts to combine the
  projected results into rows using the following algorithm:</p>
  <ol type="1">
    <li>For any two different queries in union queries, check if their
    projected columns are compatible.
    <ol type="A">
      <li>Let Q<sub>x</sub> and Q<sub>y</sub> denote the queries to be
      checked.</li>
      <li>For any column C in Q<sub>x</sub>, it MUST satisfy one of the
      following condition:
      <ol type="i">
        <li>No column in Q<sub>y</sub> has the same name, and C is
        nullable.</li>
        <li>Another column C' in Q<sub>y</sub> has the same name or alias as C,
        and the column has exactly the same data type.</li>
      </ol>
      Otherwise a <a>TypeError</a> will be thrown.</li>
    </ol></li>
    <li>Union all qualified columns as new projection list, execute the
      queries. Query engine CAN decide the execution orders. Final projected
      rows MUST be generated in the order of union queries, i.e. the rows from
      <code>union()</code> query first, then in the order of the parameters
      inside <code>union()</code>.</li>
  </ol>
  <pre class="example highlight">
var db;

function getOrderList() {
  var order = db.schema().table('Order');

  var archive = db.schema().table('ArchivedOrder');

  var query = db.select(order.item, order.amount)
                .from(order)
                .where(order.category.eq('Clothing'))
                .union(db.select(archive.item, archive.amount)
                         .from(archive)
                         .where(archive.category.eq('Clothing')));
}

  </pre>
</section>

<section>
  <h2>Intersect and Except</h2>
  <p>Intersect and except are different from joins, they just attempt to
  perform set operations on the projected results from involving queries.
  The set of projected columns from any two queries involved MUST be identical
  in name/alias and data type, otherwise a <a>TypeError</a> will be thrown.</p>
  <p>Results returned from <code>intersect()</code> include all the rows that
  exist in all involved queries.</p>
  <p>Results returned from <code>except()</code> exists only in the calling
  query.</p>
</section>


</section>

<section>
  <h2>Errors</h2>
  <p>All errors in this specification are <code>DOMException</code> with the
  specified error type.</p>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td><dfn><code>BlockingError</code></dfn></td>
      <td>Attempts to open a delete pending database, or to create a
        transaction in a close pending connection.</td></tr>
    <tr><td><dfn><code>BindingError</code></dfn></td>
      <td>The values given in <a>IQuery.bind</a> have type match, or the
        executing query has unprovided bindable values.</td></tr>
    <tr><td><dfn><code>ConstraintError</code></dfn></td>
        <td>Constraints are violated.</td>
    </tr>
    <tr><td><dfn><code>DataError</code></dfn></td>
        <td>Data given to a column is invalid. For example, assigning <code>
            null</code> or <code>undefined</code> to a <a>NOT NULL</a> column,
            or assigning values of different <a href="#column-type">column type
            </a>.</td>
    </tr>
    <tr><td><dfn><code>IntegrityError</code></dfn></td>
        <td>Query engine is not able to ensure data integrity. For example,
        failed to rollback a sequence mode transaction.</td></tr>
    <tr><td><dfn><code>InvalidSchemaError</code></dfn></td>
        <td>Provided schema is invalid.</td>
    </tr>
    <tr><td><dfn><code>RuntimeError</code></dfn></td>
        <td>Invalid query has slipped through syntax checks but caught by
        the query execution engine.</td></tr>
    <tr><td><dfn><code>SyntaxError</code></dfn></td>
      <td>Illegal use of query builder objects, for example, calling
      <code>into()</code> twice for <a>IInsertQuery</a>.</td></tr>
    <tr><td><dfn><code>TimeoutError</code></dfn></td>
      <td>Transaction takes too long to resolve (commit) or reject (rollback),
      and is automatically rolled back.</td></tr>
    <tr><td><dfn><code>TransactionStateError</code></dfn></td>
      <td>Attempts to commit/rollback/attach query to a finished/pending finish
        transaction.</td></tr>
    <tr><td><dfn><code>TypeError</code></dfn></td>
      <td>Attempts to compare/union two different data types.</td></tr>
    <tr><td><dfn><code>UnsupportedError</code></dfn></td>
      <td>Attempts to use MAY support features that are not supported yet.
      </td></tr>
  </table>
</section>


    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
      Many thanks to people who have contributed to this specification and
      helped to improve it by sending suggestions and corrections.
      </p>
      <p>
      We also want to thank the authors of
      <a href="https://www.w3.org/respec/">ReSpec</a>,
      <a href="https://nodejs.org/">Node.js</a>, and
      <a href="https://gulpjs.com/">gulp.js</a> for the powerful and handy
      tools that are used to produce this spec.
      </p>
    </section>
 </body>
</html>
