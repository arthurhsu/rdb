<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>Relational Database API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'ED',
        shortName: 'rdb',
        editors: [
          {
            name: 'Arthur Hsu',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          },
          {
            name: 'Demetrios Papadopoulos',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          }
        ],
        wg: 'Relational Database API Interest Group',
        wgURI: 'https://www.github.com/arthurhsu/rdb',
        edDraftURI: 'https://www.github.com/arthurhsu/rdb'
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
      This document defines APIs and behaviors of a relational database. The
      capabilities of the defined relational database are comparable to a 
      subset of SQL-03 standard.
      </p>
    </section>

    <section id="sotd">
      <p>This document has not been submitted to anywhere yet.</p>
    </section>

<section class="informative">
  <h2>Introduction</h2>
  <p>Relational data manipulation for the web apps has been in a difficult
  state for years. WebSQL has quite a few problems with itself and hence
  deprecated. IndexedDB, on the other hand, is an object database. In this
  document, a set of easy-to-use APIs are defined to promote readable,
  maintainable, and performant code for apps needing relational data.</p>

  <p>The APIs proposed in this document are designed for small-scale relational
  data manipulation. The following example shows how to open a database.</p>
  <pre class="example highlight">
// Open database named 'hr'.
// If the named instance does not exist, create an empty database instance.
// Otherwise, open the existing database named 'hr'.
var db;

function connect() {
  return navigator.db.open('hr').then(function(instance) {
    db = instance;

    // version is a read-only number that is for reference only.
    if (db.version == 0) {
      // This is an empty database.
      return setUpNewDb();
    } else if (db.version < 2) {
      // Version is smaller than expected, perform upgrades.
      return upgradeDb();
    }
  });
}

function setUpNewDb() {
  var tx = db.createTransaction('readwrite');
  var q1 = db.createTable('Dept')
             .column(/* column_name */ 'id',
                     /* column_type */ 'String',
                     /* not_null */ true)
             .column('name', 'String', true)
             .column('desc', 'String')
             .primaryKey([{'name': 'id'}]);

  var q2 = db.createTable('Emp')
             .column('id', 'Number', true)
             .column('name', 'String', true)
             .column('deptId', 'String', true)
             .column('title', 'String')
             .primaryKey([{name: 'id', order: 'asc'}])
             .unique(['name'])
             .index('idx_Desc', [{name: 'desc', order: 'asc'}])
             .foreignKey({
               'name': 'fk_DeptId',
               'local': 'deptId',
               'remote': 'Dept.id',
               'action': 'restrict',
               'timing': 'immediate'
             });
  var q3 = db.setVersion(2);

  tx.append([q1, q2, q3]);
  return tx.commit();
}

function upgradeDb() {
  return db.alterTable('Dept').addColumn('desc', 'String').commit();
}

connect().then(function() {
  // Real work starts here.
});

  </pre>
  <p>Once the database is opened, queries can be performed.</p>
  <pre class="example highlight">
var db;
var d = db.schema().table('Dept');

function insertData() {
  var deptData = [
    {'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
    {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
    {'id': 'NADA', 'name': 'Non existing'},
    {'id': 'L', 'name': 'Leadership'}
  ];
  return db.insert().into(d).values(deptData).commit();
}

function updateData() {
  return db.update(d).set(d.desc, 'Master minds').where(d.id.eq('L')).commit();
}

function deleteData() {
  return db.delete().from(d).where(d.id.eq('NADA')).commit();
}

function selectData() {
  return db.select().from(d).commit();
}

insertData().then(function() {
  return updateData();
}).then(function() {
  return deleteData();
}).then(function() {
  return selectData();
}).then(function(rows) {
  // Expected returns:
  // [{'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
  //  {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
  //  {'id': 'L', 'name': 'Leadership', 'desc': 'Master minds'}]
  console.log(rows);
});

  </pre>

  <p>The proposed spec defines the behaviors of a database. A database consists
  of two parts: storage and query engine. Data is stored in the storage as
  rows, each row is a tuple of values, and the types of values are defined as
  columns. Same class of rows are grouped together as a table. The database
  has a concept named schema to define columns inside tables, and the relations
  among rows. Query engine is responsible for reading and writing rows from the
  storage, enforcing relations defined in the schema, and providing various
  functions to manipulate how the rows are read and written.</p>
</section>

    <section id="conformance"></section>

<section>
  <h2>Schema</h2>
  <section>
    <h2>Overview</h2>
    <p>A schema defines the storage structure of a relational database.
    A schema MUST have a name. The origin of the page and the schema name
    together uniquely identify a database instance during runtime.</p>

    <p>A schema has a referential version number associated with it. Version
    number is an integer greater than zero and can be freely assigned. It has
    no effect on identifying a database. It is provided for the convenience of
    developers to version their schema without extra table.</p>

    <p>A schema is structured in a hierachical way. A database schema contains
    one or more tables. A table contains one or more columns, zero or more
    indices, and zero or more constraints. The collection of columns in a table
    defines the fields carried by a row, which is the fundamental unit of data
    storage in relational database. Each column consists a name and an
    associated data type. The indices hint the database engine to build index
    structures so that subsequent queries can be acclerated. Index definitions
    MAY be honored if the database engine determined that they are necessary.
    The constraints define the relations of rows and ensures data integrity,
    and MUST be honored.</p>

    <p>The database schema can be described in JSON format or constructed via
    builder pattern APIs. Schema can be changed through schema queries within
    any <code>readwrite</code> transactions. The JSON format and related APIs
    are described in the following sections.</p>
  </section>

<section>
  <h2>Naming Rules</h2>
  <p>Names in schema means identifiers used to identify an entity, such as
  database, table, column, index, constraint, and so on. All names used in the
  database schema MUST abide the following rules:</p>
  <ul>
    <li>Names are case sensitive</li>
    <li>A name MUST pass the following check:
        <code>/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)</code>
    </li>
    <li>A name MUST NOT conflict with fields defined in
        <code>Object.prototype</code>
    </li>
  </ul>
</section>

<section>
  <h2>Column Types</h2>
  <p>All columns in a table schema MUST be associated with a given type. Valid
  types of a column are defined in <code>ColumnType</code></p>
  <dl title="enum ColumnType" class="idl">
    <dt>blob</dt><dd>JavaScript type <code>ArrayBuffer</code></dd>
    <dt>boolean</dt><dd>JavaScript type <code>boolean</code></dd>
    <dt>date</dt><dd>JavaScript type <code>Date</code></dd>
    <dt>number</dt><dd>JavaScript type <code>number</code></dd>
    <dt>string</dt><dd>JavaScript type <code>string</code></dd>
    <dt>object</dt><dd>Generic JavaScript <code>Object</code></dd>
  </dl>
  <pre class="idl">
    typedef (ArrayBuffer or boolean or Date or number or DOMString or object) ValueType;
    typedef (boolean or Date or number or DOMString) IndexableValueType;
  </pre>

  <p>Only some value types are <dfn>indexable</dfn>, which means that they can 
  be compared, sorted, and used in indices and predicates. Non-indexable types,
  <code>blob</code> and <code>object</code>, MUST NOT be used to create indices
  and predicates, except the <code>isNull()</code> and <code>isNotNull()</code>
  predicates.</p>
</section>

<section>
  <h2>Orders</h2>
  <p>There are two sorting orders defined in the following enum:</p>
  <dl title="enum Order" class="idl">
    <dt>asc</dt>
    <dd>Represents ascending sort order (Default)</dd>
    <dt>desc</dt>
    <dd>Represents descending sort order</dd>
  </dl>
  <p>Ascending sort order is the natural sort order, which means that if two
  fields are ordered as <code>a, b</code>, then <code>(a <= b) === true</code>.
  <code>blob</code> and <code>object</code> types are not <a>indexable</a>,
  which implied they were not comparable and thus the orders have no effect for
  these two types.</p>
</section>

<section>
  <h2>Schema Definition JSON Format</h2>
  <p>Database schema can be defined using a single dictionary object. The
  following example demonstrates how to create a database using such object.</p>
  <pre class="example highlight">
// Create a database using predefined JSON schema.
var hrSchema = {
  'name': 'hr',
  'version': 2,
  'table': [
    {
      'name': 'Dept',
      'column': [
        {'name': 'id', 'type': 'string'},
        {'name': 'name', 'type': 'string', 'notNull': true}
      ],
      'constraint': {
        'primaryKey': 'id'
      }
    },
    {
      'name': 'Emp',
      'column': [
        {'name': 'id', 'type': 'number'},
        {'name': 'name', 'type': 'string'},
        {'name': 'deptId', 'type': 'string'},
        {'name': 'title', 'type': 'string'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id', 'order': 'desc'}],
        'foreignKey': [{
          'name': 'fk_DeptId',
          'local': 'deptId',
          'remote': 'Dept.id',
          'action': 'restrict',
          'timing': 'immediate'
        }],
        'unique': [{
          'name': 'uq_Name',
          'column': [{'name': 'name', 'order': 'desc'}]
        }],
        'notNull': ['id', 'name', 'deptId']
      },
      'index': [
        {
          'name': 'idx_Title',
          'column': [{'name': 'title', 'order': 'asc'}]
        }
      ]
    }
  ]
};

var db;
navigator.db.open('hr').then(function(connection) {
  db = connection;
  var version = db.schema().version;
  if (version == 0) {
    return db.create(hrSchema).commit();
  }
  return Promise.resolve();
}).then(function() {
  // Database created, do something here.
});

  </pre>

  <p>Any violation of the rules described in this section will result in
  <a>InvalidSchemaError</a> exception. Any name not obeying
  <a href="#naming-rules">Naming Rules</a> will also result in
  <a>InvalidSchemaError</a> exception.</p>

  <p>The following WebIDL defines <code>Schema</code> dictionary type.
  <pre class="idl">
    dictionary Schema {
      DOMString name;
      unsigned short version = 1;
      TableSpec[] table;
    };
  </pre>
  <dl class="dictionary-members">
    <dt><code>name</code></dt>
    <dd>Name of the database.</dd>
    <dt><code>version</code></dt>
    <dd>Version of the database, for reference only.</dd>
    <dt><code>table</code></dt>
    <dd>Array of <a href="#table-specifications">table specifications</a>, and
    it MUST NOT be empty.</dd>
  </dl>

  <section>
    <h2>Table Specifications</h2>
    <p>The following WebIDL defines table specification dictionary type.</p>
    <pre class="idl">
      dictionary TableSpec {
        DOMString name;
        ColumnSpec[] column;
        ConstraintSpec? constraint;
        IndexSpec[]? index;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the table, MUST be unique within the database.</dd>
      <dt><code>column</code></dt>
      <dd>Array of <a href="#column-specifications">column specifications</a>,
      and it MUST NOT be empty.</dd>
      <dt><code>constraint</code></dt>
      <dd>(Optional)
      <a href="#constraint-specifications">Constraint specifications</a>.</dd>
      <dt><code>index</code></dt>
      <dd>(Optional) Array of
      <a href="#index-specifications">index specifications</a>, and it MUST NOT
      be empty when specified.</dd>
    </dl>
  </section>

  <section>
    <h2>Column Specifications</h2>
    <p>The following WebIDL defines column specification dictionary type:</p>
    <pre class="idl">
      dictionary ColumnSpec {
        DOMString name;
        ColumnType type;
        boolean notNull = false;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the column, MUST be unique within the containing table.</dd>
      <dt><code>type</code></dt>
      <dd>Associated column type of the column.</dd>
      <dt><code>notNull</code></dt>
      <dd>When specified as <code>true</code>, the column is <a>NOT NULL</a>.
      </dd>
    </dl>
    <p><dfn>NOT NULL</dfn> means the column MUST NOT have a value of
    <code>undefined</code> or <code>null</code>.</p>
    <p>A column has a <dfn>canonical name</dfn>, which is represented as
    <code>&lt;containing table name&gt;.&lt;column name&gt;</code>. One can
    <dfn>refer</dfn> to a column by its name, if the referral is happened
    within the table scope; or by its <a>canonical name</a> from anywhere
    within the database.</p>
  </section>

  <section>
    <h2>Index Specifications</h2>
    <p>The following WebIDL defines index specification dictionary type:</p>
    <pre class="idl">
      typedef (DOMString or DOMString[] or IndexedColumnSpec[]) IndexedColumnDefinition;
      dictionary IndexSpec {
        DOMString name;
        IndexedColumnDefinition column;
        IndexType type = "btree";
        boolean unique = false;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the index, MUST be unique within the containing table.</dd>
      <dt><code>column</code></dt>
      <dd>Indexed column definitions. If provided as
          <code>DOMString</code>, the string MUST <a>refer</a> to an
          <a>indexable</a> column of the containing table; if provided as
          <code>DOMString[]</code>, it MUST NOT be empty, and the strings MUST
          <a>refer</a> to different <a>indexable</a> columns of the containing
          table. In these two cases, default sort order of <code>asc</code> is
          used. If provided as <code>IndexedColumnSpec[]</code>, it MUST NOT
          be empty, and each <code>IndexedColumnSpec</code> MUST <a>refer</a>
          to different column.</dd>
      <dt><code>type</code></dt>
      <dd>(Optional) Type of index, default to <code>btree</code></dd>
      <dt><code>unique</code></dt>
      <dd>(Optional) Keys in index shall be unique or not,
          default to <code>false</code>.</dd>
    </dl>
    <p>Index type allows user to hint the query engine to create an index on
    specified columns in given sorting orders. The query engine MAY construct
    the index, MAY follow the given sorting orders, and MAY use the specified
    type. The query engine can refuse to construct the index as specified, or
    construct a different index.</p>

    <p>The index type is an enum:</p>
    <dl title="enum IndexType" class="idl">
      <dt>btree</dt><dd>B+ Tree index</dd>
      <dt>hash</dt><dd>Hash index</dd>
    </dl>

    <p>An index can be keyed by one or more columns. A <dfn>unique key</dfn>
    means that the value or combination of values used as index key is unique
    within the index. By default, all indices allow duplicate keys unless the
    <code>unique</code> is set to true. A <a>ConstraintError</a> will be thrown
    if user tried to insert/update a row with duplicated key when a unique
    index is specified.</p>

    <p>The WebIDL below defines indexed column specification.</p>
    <pre class="idl">
      dictionary IndexedColumnSpec {
        DOMString name;
        Order order = "asc";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the indexed column, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>order</code></dt>
      <dd>(Optional) Sorting order of the column, default to
          <code>asc</code>.</dd>
    </dl>
    <p>If an index definition overlapped with implicit indices created by
    constraints (for example, create an index on the same column of the primary
    key), it will be up to the query engine to determine whether or not to
    create this index.</p>
  </section>

  <section>
    <h2>Constraint Specifications</h2>
    <p>The following WebIDL defines constraint specification.</p>
    <pre class="idl">
      typedef (DOMString or DOMString[] or IndexedColumnSpec[] or PrimaryKeySpec) PrimaryKeyDefinition;
      dictionary ConstraintSpec {
        PrimaryKeyDefinition? primaryKey;
        ForeignKeySpec? foreignKey;
        UniqueSpec? unique;
        (DOMString or DOMString[])? notNull;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>primaryKey</code></dt>
      <dd>(Optional) <a href="#primary-key-specification">Primary key
      specification</a>.</dd>
      <dt><code>foreignKey</code></dt>
      <dd>(Optional) <a href="#foreign-key-specification">Foreign key
      specification</a>.</dd>
      <dt><code>unique</code></dt>
      <dd>(Optional) <a href="#unique-index-specification">Unique index
      specification</a>.</dd>
      <dt><code>notNull</code></dt>
      <dd>(Optional) Column(s) that are <a>NOT NULL</a>.</dd>
    </dl>
    <p>The name(s) specified in the notNull MUST <a>refer</a> to column(s)
    of the containing table. When provided as <code>DOMString[]</code>, the
    array MUST NOT be empty, and they MUST <a>refer</a> to different
    columns.</p>
  </section>

  <section>
    <h2>Unique Index Specification</h2>
    <p>Unique index is a specialized index that disallows duplicated keys.
    Its definition format is the same as index definition. If two or more
    columns are defined as keys, the combination of the column values forms the
    uniqueness.</p>
    <pre class="idl">
      dictionary UniqueSpec {
        DOMString name;
        IndexedColumnDefinition column;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the index, MUST be unique within the containing table.</dd>
      <dt><code>column</code></dt>
      <dd>Same as the <code>column</code> in <a href="#index-specifications">
      Index Specifications</a>.</dd>
    </dl>
  </section>

  <section>
    <h2>Primary Key Specification</h2>
    <p>Primary key is a specialized unique index. Each table can have only one
    primary key. A primary key can be specified using unique index
    specification, or use the following WebIDL:</p>
    <pre class="idl">
      dictionary PrimaryKeySpec {
        DOMString name;
        boolean autoIncrement;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt><dd>Column name of the primary key, MUST
      <a>refer</a> to <a>indexable</a> column of the containing table.</dd>
      <dt><code>autoIncrement</code></dt><dd>Create auto-increment
      primary key.</dd>
    </dl>
    <p>When the autoIncrement field is specified, the specified column MUST be
    of type <code>Number</code>. An auto-increment key will start from zero.
    When a new row is inserted into the table, the key will increase by one and
    assigned to that row regardless the original key value given to the
    row.</p>
    <p class="note">Unlike SQL, primary key does not have name.</p>
  </section>

  <section>
    <h2>Foreign Key Specification</h2>
    <p>The following WebIDL defines foreign key specification.</p>
    <pre class="idl">
      dictionary ForeignKeySpec {
        DOMString name;
        DOMString local;
        DOMString remote;
        ForeignKeyAction action = "restrict";
        ForeignKeyTiming timing = "immediate";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the foreign key, MUST be unique withing the containing table.
      </dd>
      <dt><code>local</code></dt>
      <dd>Referring column name, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>remote</code></dt>
      <dd>Referred column <a>canonical name</a>, MUST <a>refer</a> to an
      <a>indexable</a> column.</dd>
      <dt><code>action</code></dt>
      <dd>(Optional) Foreign key action, default to <code>restrict</code>.</dd>
      <dt><code>timing</code></dt>
      <dd>(Optional) Foreign key timing, default to <code>immediate</code>.
      </dd>
    </dl>
    <p>A <dfn>chainned foreign key</dfn> means the <code>remote</code> column
    is also a <code>local</code> column of another foreign key, which forms a
    dependency. The query engine MAY support chainned foreign key. The query
    engine MAY support referred column to be within the containing table.</p>

    <p>Foreign key actions are enum values as defined in the following:</p>
    <dl title="enum ForeignKeyAction" class="idl">
      <dt>restrict</dt>
      <dd>Any constraint violation results in cancelling the operation that
      violated the constraint.</dd>
      <dt>cascade</dt>
      <dd>Constraint violation results in modifying related tables as necessary
      to maintain data integrity.</dd>
    </dl>
    <p>Foreign key timings are enum values as defined below:</p>
    <dl title="enum ForeignKeyTiming" class="idl">
      <dt>deferrable</dt>
      <dd>The constraint is enforced right before a transaction is committed.
      The constraint can be violated by individual queries during the lifetime
      of the enclosing transaction, without any error being thrown.</dd>
      <dt>immediate</dt>
      <dd>The constraint is enforced during execution of each individual query.
      </dd>
    </dl>
  </section>

</section>

<section>
  <h2>Schema Query</h2>
  <p>A database instance is created using schema queries. The associated schema
  of the database can also be altered using schema queries. Schema queries are
  run in the context of <a>transaction</a> and can be executed any time during
  the life time of the database.</p>

  <section>
    <h2>Database-Level Schema Query</h2>
    <p>The <code>ISchemaQueryProvider</code> is the interface of manipulating
    database-level schema:</p>
    <pre class="idl">
      interface ISchemaQueryProvider {
        IExecutionContext exportSchema();
        IExecutionContext create(Object schema);
        IExecutionContext setVersion(unsigned short version);
        IExecutionContext setForeignKeyCheck(boolean value);
        IDatabaseSchema schema();
        ITableBuilder createTable();
        ITableChanger alterTable();
        IExecutionContext dropTable(DOMString name);
      };
    </pre>
    <dl class="methods">
      <dt><code>IExecutionContext exportSchema();</code></dt>
      <dd>Export schema object, MUST be run in the context of a
      <a>transaction</a>.</dd>
      <dt><code>IExecutionContext create(Object schema);</code></dt>
      <dd>Create database schema from provided schema object, MUST be run in
      the context of a <a>transaction</a>. The schema object MUST conform to
      the format defined in <a href="#schema-definition-json-format">
      Schema Definition JSON Format</a>. Any error in the schema will result in
      transaction failure with <a>InvalidSchemaError</a>.</dd>
      <dt><code>IExecutionContext setVersion(unsigned short version);</code>
      </dt>
      <dd>Sets the version number of the schema, MUST be run in the context of
      a <a>transaction</a>.</dd>
      <dt><code>IExecutionContext setForeignKeyCheck(boolean value);</code></dt>
      <dd>Enables or disables foreign key constraint enforcement within the
      transaction that the execution context returned by this function is in.
      Misuse of this function MAY cause broken data integrity.
      </dd>
      <dt><code>IDatabaseSchema schema();</code></dt>
      <dd>Returns an <code>IDatabaseSchema</code> object for crafting data
      manipulation queries.</dd>
      <dt><code>ITableBuilder createTable();</code></dt>
      <dd>Returns a <a href="#table-builder">table builder</a> for creating a
      new table.</dd>
      <dt><code>ITableChanger alterTable(string tableName);</code></dt>
      <dd>Returns a <a href="#table-changer">table changer</a> for altering an
      existing table. The table referred by <code>tableName</code> MUST already
      exist in the database, otherwise a <a>DataError</a> will be raised.</dd>
      <dt><code>IExecutionContext dropTable(DOMString name);</code></dt>
      <dd>Removes a table and all its rows from database. The table referred by 
      <code>name</code> MUST already exist in the database, otherwise a
      <a>DataError</a> will be raised.</dd>
    </dl>
  </section>
  <section>
    <h2>Database Schema</h2>
    <p>Database schema obtained from <code>ISchemaQueryProvider.schema()</code>
    provides <code>IDatabaseSchema</code> interface.</p>
    <pre class="idl">
      interface IDatabaseSchema {
        readonly attribute DOMString name;
        readonly attribute unsigned short version;
        object table(DOMString tableName);
      };
    </pre>
    <dl class="attributes">
      <dt><code>DOMString name</code></dt>
      <dd>Name of the database.</dd>
      <dt><code>unsigned short version</code></dt>
      <dd>Version of the database schema.</dd>
    </dl>
    <dl class="methods">
      <dt><code>object table(DOMString tableName);</code></dt>
      <dd>Returns a read-only dictionary object, whose members are
      <a>IColumn</a> objects representing columns in the specified table.
      The table referred by <code>tableName</code> MUST already exist in the
      database, otherwise a <a>DataError</a> will be raised.</dd>
    </dl>
  </section>

  <section>
    <h2>Table Builder</h2>
    <p>Table builder is used to describe the new table that will be created,
    and MUST be used within the context of a <a>transaction</a>.</p>
    <pre class="idl">
      interface ITableBuilder : IExecutionContext {
        ITableBuilder column(DOMString name, ColumnType type, optional boolean notNull = false);
        ITableBuilder primaryKey(PrimaryKeyDefinition primaryKey);
        ITableBuilder foreignKey(ForeignKeySpec foreignKey);
        ITableBuilder unique(DOMString name, IndexedColumnDefinition columns);
        ITableBuilder index(DOMString name, IndexedColumnDefinition columns);
      };
    </pre>
    <p>All methods returns the same <code>ITableBuilder</code> object that
    they were called from to make cascade builder pattern possible. If any of
    the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times except <code>primaryKey</code>.</p>
    <dl class="methods">
      <dt><code>ITableBuilder column(DOMString name, ColumnType type, optional boolean notNull = false);</code></dt>
      <dd>Adds a column to table. <code>name</code> MUST be unique within the
      containing table.</dd>
      <dt><code>ITableBuilder primaryKey(PrimaryKeyDefinition primaryKey);</code></dt>
      <dd>Adds a primary key to table. This method MUST NOT be called multiple
      times.</dd>
      <dt><code>ITableBuilder foreignKey(ForeignKeySpec foreignKey);</code></dt>
      <dd>Adds a foreign key to table.</dd>
      <dt><code>ITableBuilder unique(DOMString name, IndexedColumnDefinition columns);
</code></dt>
      <dd>Adds an unique index to table. The <code>name</code> is the name of
      the index, and it MUST be unique within the containing table.</dd>
      <dt><code>ITableBuilder index(DOMString name, IndexedColumnDefinition columns);
</code></dt>
      <dd>Adds an index to table. The <code>name</code> is the name of the
      index, and it MUST be unique within the containing table.</dd>
    </dl>
  </section>

  <section>
    <h2>Table Changer</h2>
    <p>Table changer is used to change the schema of an existing table, and
    MUST be used within the context of a <a>transaction</a>. If the table
    already contains data, altering table schema can cause constraint
    violations and fail the transaction.</p>
    <pre class="idl">
      interface ITableChanger : IExecutionContext {
        ITableChanger rename(DOMString newTableName);
        ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);
        ITableChanger dropColumn(DOMString name);
        ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);
        ITableChanger dropPrimaryKey();
        ITableChanger addForeignKey(ForeignKeySpec foreignKey);
        ITableChanger addUnique(DOMString name, IndexedColumnDefinition columns);
        ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);
        ITableChanger dropConstraintOrIndex(DOMString name);
        IColumnChanger setColumn(DOMString name);
      };
    </pre>
    <p>All methods returns the same <code>ITableChanger</code> object that
    they were called from to make cascade builder pattern possible, except that
    <code>setColumn</code> will return a <a>IColumnChanger</a> instead. If any
    of the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times.</p>
    <dl class="methods">
      <dt><code>ITableChanger rename(DOMString newTableName);</code></dt>
      <dd>Renames the table, <code>newTableName</code> MUST be unique within the
      database, and MUST NOT be the same as existing table name.</dd>
      <dt><code>ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);</code></dt>
      <dd>Adds a new column to table, <code>name</code> MUST be unique within
      the containing table. If <code>defaultValue</code> is given, it MUST
      be of the same type as specified in <code>type</code>. Every existing row
      in the table will be added a new column with </code>defaultValue</code>.
      </dd>
      <dt><code>ITableChanger dropColumn(DOMString name);</code></dt>
      <dd>Removes a column from table. The <code>name</code> MUST <a>refer</a>
      to an existing column in the table schema. The referred column MUST NOT
      be the only column in the table schema, and MUST NOT be referred by any
      index nor constraints. Every existing row in the table will be modified
      to remove the field represented by that column.</dd>
      <dt><code>ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);</code></dt>
      <dd>Adds a primary key to table, the table MUST not have existing primary
      key.</dd>
      <dt><code>ITableChanger dropPrimaryKey();</code></dt>
      <dd>Removes primary key from table. If the table does not have primary
      key, this method will do nothing.</dd>
      <dt><code>ITableChanger addForeignKey(ForeignKeySpec foreignKey);</code></dt>
      <dd>Adds a foreign key to the table.</dd>
      <dt><code>ITableChanger addUnique(DOMString name, IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an unique index to the table. The <code>name</code> is the name
      of the unique index and MUST be unique within the containing table.</dd>
      <dt><code>ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an index to the table. The <code>name</code> is the name
      of the index and MUST be unique within the containing table.</dd>
      <dt><code>ITableChanger dropConstraintOrIndex(DOMString name);</code></dt>
      <dd>Removes a constraint or index in table by name. The <code>name</code>
      MUST refer to an existing constraint or index.</dd>
      <dt><code>IColumnChanger setColumn(DOMString name);</code></dt>
      <dd>Changes a column in the table, and the <code>name</code> MUST
      <a>refer</a> to an existing column in the table schema.</dd>
    </dl>
  </section>

  <section>
    <h2>Column Changer</h2>
    <pre class="idl">
      interface IColumnChanger {
        ITableChanger set(DOMString newColumnName, optional boolean notNull = true);
      };
    </pre>
    <dl class="methods">
      <dt><code>ITableChanger set(DOMString newColumnName, optional boolean notNull = true);</code></dt>
      <dd>Changes the column's name or <a>NOT NULL</a> property. The returned
      <code>ITableChanger</code> is the parent object that creates this object.
      </dd>
      <p class="note">Changing column data type is not supported by this spec.
      JavaScript is famous of tricky type conversions and it is unlikely to
      have conversion rules that covers every corner case.</p>
    </dl>
  </section>

  <section class="informative">
    <h2>Schema Query Examples</h2>
    <p>The following example demonstrates how to create a database schema.</p>
    <pre class="example highlight">
var db;
var tx = db.createTransaction('readwrite');
var q1 = db.createTable('Dept')
           .column(/* column_name */ 'id',
                   /* column_type */ 'string',
                   /* not_null */ true)
           .column('name', 'string', true)
           .primaryKey([{'name': 'id'}]);
tx.append(q1);

var q2 = db.createTable('Emp')
           .column('id', 'number', true)
           .column('name', 'string', true)
           .column('deptId', 'string', true)
           .column('title', 'string')
           .primaryKey([{'name': 'id', 'order': 'asc'}])
           .unique(['name'])
           .index('idx_Desc', [{'name': 'desc', 'order': 'asc'}])
           .foreignKey({
             'name': 'fk_DeptId',
             'local': 'deptId',
             'remote': 'Dept.id',
             'action': 'restrict',
             'timing': 'immediate'
           });
q2.attachTo(tx);

tx.commit().then(function() {
  // Table created, do something here.
});

    </pre>
    <p>The following example shows how to alter database schema during schema
    upgrade.</p>
    <pre class="example highlight">
var db;
var version = db.schema().version();

if (version < 2) {
  // Need DB upgrade.
  var tx = db.createTransaction('readwrite');
  var q1 = db.setVersion(2);
  var q2 = db.createTable('NewTable')
             .column('id', 'string', true)
             .column('name', 'string', true);
  var q3 = db.alterTable('Emp')
             .addColumn('location', 'string', true, 'LAX')
             .setColumn('title').set('title', true)  // Change to NOT NULL
             .addIndex('idx_location', 'location');
  var q4 = db.dropTable('Foo');
  tx.exec([q1, q2, q3, q4]).then(function() {
    // Update data after schema has changed.
  });
}

    </pre>
  </section>
</section>


</section>

<section>
  <h2>Database</h2>

<section>
  <h2>Overview</h2>
  <p>A database's origin is the same as the origin of the document or worker.
  Each origin has an associated set of database.</p>

  <p class="note">The database origin is not affected by changes to
  <code>document.domain</code>.</p>

  <p>Each origin has an associated set of databases. A database comprises one
  or more tables which hold the data stored in the database.</p>

  <p>Every database has a <em>name</em> which identifies it within a specific
  origin. The name MUST satisfy the Naming Rules, and stay constant for the
  lifetime of the database.</p>

  <p>Each database also has a version number for reference only. When a
  database is first created, its version is 0.</p>

  <p class="note">Implementations MUST support all names. If an implementation
  uses a storage mechanism which can't handle arbitrary database names, the
  implementation MUST use an escaping mechanism or something similar to map
  the provided name to a name that it can handle.</p>

  <p>Databases has a <em>delete pending</em> flag which is used during
  deletion. When a database is requested to be deleted the flag is set to true
  and all attempts at opening the database are stalled until database is
  deleted.</p>

  <p>The act of opening a database creates a <em>connection</em>. There may be
  multiple connections to a given database at any given time. Each connection
  has a <em>closePending</em> flag which initially is set to false.</p>

  <p>When a connection is initially created it is in opened state. The
  connection can be closed through several means. If the connection is garbage
  collected or execution context where the connection is created is destroyed
  (for example due to the user navigating away from that page), the connection
  is closed. The connection can also be closed explicitly using the steps for
  closing a database connection. When the connection is closed the
  closePending flag is always set to true if it hasn't already been. All
  uncommitted transactions will be canceled if their associated connections
  are marked close pending.</p>

  <p>Every database contains zero or more <em>tables</em> to store data. A
  table contains zero or more <em>rows</em>. A row is also known as a record or
  a tuple, which represents a single structured data item in a table. A row
  consists zero or more <em>columns</em>, each with predefined data types.
  A database can also contain <em>indices</em>. An index is a data structure
  that enables fast look up and/or enforces data integrity.</p>

  <p>Every database has a predefined layout of the data structures persisted,
  which is referred as <em>schema</em> throughout this document. A database
  schema consists of a list of table schema. Each table schema describes the
  structures of the rows stored within it, which is also referred as 
  <em>column definitions</em>. A table schema also describes
  <em>constraints</em> and <em>index</em> structures for that table.</p>

  <p>Users can create observers associated with a given database. Each
  observer consists a select query. When the results of that select query
  change, the observer will be triggered.</p>

  <p>The <code>IDatabaseConnection</code> interface represents a connection to
  a database.</p>
</section>

<section>
  <h2>Database API</h2>
  <p>The database is defined by the following WebIDL.</p>
  <pre class="idl">
    interface IRelationalDatabase {
      readonly attribute IDatabaseFunctionProvider fn;

      Promise< DatabaseConnection > open(DOMString name, OpenDatabaseOptions? opt);
      Promise< void > drop(DOMString name);
    };
  </pre>
  <dl class="attributes">
    <dt><code>IDatabaseFunctionProvider fn</code></dt>
    <dd>Provides a namespace for aggregation functions that can be used in
    queries.</dd>
  </dl>
  <dl class="methods">
    <dt><code>Promise< DatabaseConnection > open(DOMString name, OpenDatabaseOptions? opt)</code></dt>
    <dd>Opens a database using provided name. If the database does not exist,
    create a new database instance and returns connection to it. If the database
    is marked delete pending, <a>BlockingError</a> will be thrown. If the
    <code>OpenDatabaseOptions</code> is not specified, a <code>persistent</code>
    database with the given name will be opened/created.</dd>
    <dt><code>Promise< void > drop()</code></dt>
    <dd>Deletes a database using provided name. This MUST follow the delete
    database algorithm.</dd>
    <dt><code>IBindableValue bind(unsigned short index);</code></dt>
    <dd>Provides a bind-able value that can be used to construct parameterized
    queries.</dd>
  </dl>

  <p>Open database options.</p>
  <pre class="idl">
    dictionary OpenDatabaseOptions {
      RDBStorageType storageType;
    };
  </pre>

  <p>The relational database is part of <code>Navigator</code> as defined in
  following WebIDL.</p>
  <pre class="idl">
    partial interface Navigator {
      readonly attribute IRelationalDatabase db;
    };
  </pre>

  The <code>RDBStorageType</code> is an enum:
  <dl title="enum RDBStorageType" class="idl">
    <dt>persistent</dt><dd>Data will be persisted in permanent storage</dd>
    <dt>temporary</dt><dd>Data will be persisted in memory only</dd>
  </dl>

  <p>When <code>storageType</code> is set to <code>temporary</code>, the
  relational database acts as in-memory cache of data and offers only the
  relational query capability. The <code>storageType</code> is fixed for the
  lifetime of returned database connection.</p>
</section>

<section>
  <h2>Connection</h2>
  <p>The following WebIDL defines a database connection.</p>
  <pre class="idl">
    interface IDatabaseConnection {
      ITransaction createTransaction(optional TransactionMode mode = "readonly");
      Promise< void > close();
      IBindableValue bind(unsigned short index);
    };

    interface DatabaseConnection : IDatabaseConnection {
      readonly attribute DOMString name;
    };
    DatabaseConnection implements IDatabaseObserver;
    DatabaseConnection implements IDatabaseSerialization;
    DatabaseConnection implements IDataQueryProvider;
    DatabaseConnection implements ISchemaQueryProvider;

  </pre>
</section>

<section>
  <h2>Serialization</h2>
  <p>The following WebIDL defines database serialization.</p>
  <pre class="idl">
    interface IDatabaseSerialization {
      Promise< object > export();
      Promise< void > import(object data);
    };
  </pre>
</section>

<section>
  <h2>Observers</h2>
  <pre class="idl">
    callback observerCallback = void (object[] rows);

    interface IDatabaseObserver {
      DOMString observe(ISelectQuery query, observerCallback callbackFn);
      void unobserve(DOMString observerKey);
    };
  </pre>
</section>


</section>

<section>
  <h2>Query and Transaction</h2>

<section>
  <h2>Schema Representation</h2>
  <pre class="idl">
    interface ITable {
      readonly attribute DOMString name;
      ITable as(DOMString alias);
    };
  </pre>

  <pre class="idl">
    interface IColumn : IPredicate {
      readonly attribute DOMString name;
      readonly attribute ColumnType type;
      readonly attribute boolean nullable;
      IColumn as(DOMString alias);
    };
  </pre>
</section>

<section>
  <h2>Transaction</h2>
  <p>A <dfn>transaction</dfn> is an atomic unit of reading and writing data in
  a database. A transaction contains one or more queries that indicate how to
  interact with the database. A transaction is an atomic unit of execution that
  guarantees all queries inside this transaction to be committed as a whole, or
  none get committed. A committed transaction guarantees all data being written
  to storage.</p>

  <p>All transactions are associated with a database connection, which is the
  <em>connection</em> that the transaction is created within. A transaction has
  a predetermined <em>mode</em> to indicate what access this transaction is
  asking for. The mode is set when the transaction is created and remains fixed
  for the life of the transaction. There are two transaction modes:</p>

  <dl title="enum TransactionMode" class="idl">
    <dt>readonly</dt>
    <dd>Transaction intends to read rows only.</dd>
    <dt>readwrite</dt>
    <dd>Transaction intends to read/write rows and/or change schema.</dd>
  </dl>

  <p>A transaction has a <em>scope</em> that determines the rows affected by
  this transaction. The scope is automatically calculated. A transaction's scope
  can dynamically change for the lifetime of the transaction.</p>

  <p>A transaction can be created explicitly or implicitly. An explicit
  transaction is created directly from connection's
  <code>createTransaction()</code> function. An implicit transaction is created
  from a query's <code>commit()</code> method.</p>

  <p>A transaction's lifetime is controlled by the user. For implicit
  transactions, <code>commit()</code> starts the execution of transaction, and
  returns a result <code>Promise</code>. The promise is resolved if and only if
  the transaction is committed, and is rejected if the transaction did not
  commit. For explicit transaction, there are two ways to start execution:
  <em>batch mode</em> and <em>sequence mode</em>. In batch mode, explicit
  transaction is started with <code>exec(queriesArray)</code> and returns
  a result <code>Promise</code>. All queries will be executed sequentially in
  the order received, and the results of last query in the transaction are
  returned in the promise. In sequence mode, user calls <code>begin()</code> to
  start the transaction, calls <code>attach(query)</code> to attach a query to
  the transaction's execution context. The user can call <code>commit()</code>
  to indicate the end of transaction, and a result <code>Promise</code> will be
  returned; or the user can call <code>rollback()</code> to abort the
  transaction, and all modifications done by previous attached queries will be
  discarded.</p>

  <p>When a transaction is committed or rolled back, it is said to be
  <em>finished</em>. A finished transaction MUST NOT be started nor rolled back.
  If a transaction's connection is lost before transaction being finished, the
  transaction is effectively aborted and no changes will be persisted.</p>

</section>

<section>
  <h2>Transaction API</h2>
  <p>Transaction is related to a journaled execution context, which is defined
  by the WebIDL below.</p>
  <pre class="idl">
    typedef (void or object[]) TransactionResults;

    interface IExecutionContext {
      Promise< TransactionResults > commit();
      Promise< void > rollback();
    };
  </pre>

  <p>The following WebIDL defines explicit transaction.</p>
  <pre class="idl">
    interface ITransaction : IExecutionContext {
      Promise< void > begin();
      Promise< TransactionResults > exec(IExecutionContext[] queries);
      Promise< TransactionResults > attach(IExecutionContext query);
    };
  </pre>

  <p>All queries must inherit from this base query interface.</p>
  <pre class="idl">
    interface IQuery : IExecutionContext {
      Promise< DOMString > explain();
      IQuery bind(any... values);
      void attachTo(ITransaction tx);
      DOMString toSql();
    };
  </pre>

  <pre class="idl">
    interface IBindableValue {
      readonly attribute any value;
    };
  </pre>
  <p>Type check of bound value is performed by query engine before executing
  the query.</p>

  <p>The following example demonstrate how to perform parameterized query using
  data binding:</p>
  <pre class="example highlight">
var db;

var query;

function init() {
  var dept = db.schema().table('Department');

  var emp = db.schema().table('Employee');
  query = db.select(emp.name.as('ename'), dept.name)
            .from(dept, emp)
            .where(dept.id.eq(emp.deptId).and(
                   emp.id.eq(db.bind(0))));
}

function updateModel(employeeId) {
  query.bind(employeeId).commit().then(function(rows) {
    console.log(rows[0]['ename'], rows[0]['Department.name']);
  });
}

  </pre>
</section>

<section>
  <h2>Data Query</h2>
  <pre class="idl">
    interface IDataQueryProvider {
      ISelectQuery select(IColumn... columns);
      IInsertQuery insert();
      IInsertQuery insertOrReplace();
      IUpdateQuery update(ITable table);
      IDeleteQuery delete();
    };
  </pre>
  <pre class="idl">
    interface ISelectQuery : IQuery {
      ISelectQuery from(ITable... tables);
      ISelectQuery where(IPredicate searchCondition);
      ISelectQuery innerJoin(ITable table, Predicate onCondition);
      ISelectQuery leftOuterJoin(ITable table, Predicate onCondition);
      ISelectQuery limit((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery skip((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery orderBy(IColumn column, optional Order order);
      ISelectQuery groupBy(IColumn... column);
    };
  </pre>
  <pre class="idl">
    interface IInsertQuery : IQuery {
      IInsertQuery into(ITable table);
      IInsertQuery values((object or object[] or IBindableValue or IBindableValue[]) rows);
    };
  </pre>
  <pre class="idl">
    interface IUpdateQuery : IQuery {
      IUpdateQuery set(IColumn column, ValueType value);
      IUpdateQuery where(IPredicate searchCondition);
    };
  </pre>
  <pre class="idl">
    interface IDeleteQuery : IQuery {
      IDeleteQuery from(ITable table);
      IDeleteQuery where(IPredicate searchCondition);
    };
  </pre>
  <pre class="idl">
    typedef (boolean or Date or number or DOMString) IndexableValueType;
    typedef (IndexableValueType or IBindableValue) ComparableValueType;

    interface IPredicate {
      IPredicate eq(ComparableValueType value);
      IPredicate neq(ComparableValueType value);
      IPredicate lt(ComparableValueType value);
      IPredicate lte(ComparableValueType value);
      IPredicate gt(ComparableValueType value);
      IPredicate gte(ComparableValueType value);
      IPredicate match((IBindableValue or RegExp) value);
      IPredicate between(ComparableValueType value, ComparableValueType value);
      IPredicate in((ComparableValueType[] or IBindableValue) values);
      IPredicate isNull();
      IPredicate isNotNull();

      IPredicate not(IPredicate childPredicate);
      IPredicate and(IPredicate... childPredicate);
      IPredicate or(IPredicate... childPredicate);
    };
  </pre>
  <pre class="idl">
    interface IAggregateFunction {
      IColumn avg(IColumn col);
      IColumn count(optional IColumn col = null);
      IColumn geomean(IColumn col);
      IColumn max(IColumn col);
      IColumn min(IColumn col);
      IColumn stddev(IColumn col);
      IColumn sum(IColumn col);
      IColumn var(IColumn col);
    };
  </pre>
  <pre class="idl">
    interface IDatabaseFunctionProvider : IAggregateFunction {
      IColumn distinct(IColumn... col);
    };
  </pre>
</section>


</section>

<section>
  <h2>Errors</h2>
  <p>All errors in this specification are <code>DOMException</code> with the
  specified error type.</p>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td><dfn><code>BlockingError</code></dfn></td>
        <td>Attempts to open a delete pending database.</td></tr>
    <tr><td><dfn><code>ConstraintError</code></dfn></td>
        <td>Constraints are violated.</td>
    </tr>
    <tr><td><dfn><code>DataError</code></dfn></td>
        <td>Data given to a column is invalid. For example, assigning <code>
            null</code> or <code>undefined</code> to a <a>NOT NULL</a> column,
            or assigning values of different <a href="#column-type">column type
            </a>.</td>
    </tr>
    <tr><td><dfn><code>InvalidSchemaError</code></dfn></td>
        <td>Provided schema is invalid.</td>
    </tr>
    <tr><td><dfn><code>TransactionStateError</code></dfn></td>
      <td>Attempts to commit or rollback a finished transaction.</td></tr>
    <tr><td><dfn><code>UnsupportedError</code></dfn></td>
      <td>Attempts to use MAY support features that are not supported yet.
      </td></tr>
  </table>
</section>

 </body>
</html>
