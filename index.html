<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>Relational Database API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'ED',
        shortName: 'rdb',
        editors: [
          {
            name: 'Arthur Hsu',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          },
          {
            name: 'Demetrios Papadopoulos',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          }
        ],
        wg: 'Relational Database API Interest Group',
        wgURI: 'https://www.github.com/arthurhsu/rdb',
        edDraftURI: 'https://www.github.com/arthurhsu/rdb'
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
      This document defines APIs and behaviors of a relational database. The
      capabilities of the defined relational database are comparable to a 
      subset of SQL-03 standard.
      </p>
    </section>

    <section id="sotd">
      <p>This document has not been submitted to anywhere yet.</p>
    </section>

<section class="informative">
  <h2>Introduction</h2>
  <p>Relational data manipulation for the web apps has been in a difficult
  state for years. WebSQL has quite a few problems with itself and hence
  deprecated. IndexedDB, on the other hand, is an object database. In this
  document, a set of easy-to-use APIs are defined to promote readable,
  maintainable, and performant code for apps needing relational data.</p>

  <p>The APIs proposed in this document are designed for small-scale relational
  data manipulation. The following example shows how to open a database.</p>
  <pre class="example highlight">
// Open database named 'hr'.
// If the named instance does not exist, create an empty database instance.
// Otherwise, open the existing database named 'hr'.
var db;

function connect() {
  return navigator.db.open('hr').then(function(instance) {
    db = instance;

    // version is a read-only number that is for reference only.
    if (db.version == 0) {
      // This is an empty database.
      return setUpNewDb();
    } else if (db.version < 2) {
      // Version is smaller than expected, perform upgrades.
      return upgradeDb();
    }
  });
}

function setUpNewDb() {
  var tx = db.createTransaction('readwrite');
  var q1 = db.createTable('Dept')
             .column(/* column_name */ 'id',
                     /* column_type */ 'String',
                     /* not_null */ true)
             .column('name', 'String', true)
             .column('desc', 'String')
             .primaryKey([{'name': 'id'}]);

  var q2 = db.createTable('Emp')
             .column('id', 'Number', true)
             .column('name', 'String', true)
             .column('deptId', 'String', true)
             .column('title', 'String')
             .primaryKey([{name: 'id', order: 'asc'}])
             .unique(['name'])
             .index('idx_Desc', [{name: 'desc', order: 'asc'}])
             .foreignKey({
               'name': 'fk_DeptId',
               'local': 'deptId',
               'remote': 'Dept.id',
               'action': 'restrict',
               'timing': 'immediate'
             });
  var q3 = db.setVersion(2);

  tx.append([q1, q2, q3]);
  return tx.commit();
}

function upgradeDb() {
  return db.alterTable('Dept').addColumn('desc', 'String').commit();
}

connect().then(function() {
  // Real work starts here.
});

  </pre>
  <p>Once the database is opened, queries can be performed.</p>
  <pre class="example highlight">
var db;
var d = db.schema().table('Dept');

function insertData() {
  var deptData = [
    {'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
    {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
    {'id': 'NADA', 'name': 'Non existing'},
    {'id': 'L', 'name': 'Leadership'}
  ];
  return db.insert().into(d).values(deptData).commit();
}

function updateData() {
  return db.update(d).set(d.desc, 'Master minds').where(d.id.eq('L')).commit();
}

function deleteData() {
  return db.delete().from(d).where(d.id.eq('NADA')).commit();
}

function selectData() {
  return db.select().from(d).commit();
}

insertData().then(function() {
  return updateData();
}).then(function() {
  return deleteData();
}).then(function() {
  return selectData();
}).then(function(rows) {
  // Expected returns:
  // [{'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
  //  {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
  //  {'id': 'L', 'name': 'Leadership', 'desc': 'Master minds'}]
  console.log(rows);
});

  </pre>

  <p>The proposed spec defines the behaviors of a database. A database consists
  of two parts: storage and query engine. Data is stored in the storage as
  rows, each row is a tuple of values, and the types of values are defined as
  columns. Same class of rows are grouped together as a table. The database
  has a concept named schema to define columns inside tables, and the relations
  among rows. Query engine is responsible for reading and writing rows from the
  storage, enforcing relations defined in the schema, and providing various
  functions to manipulate how the rows are read and written.</p>
</section>

    <section id="conformance"></section>

<section>
  <h2>Schema</h2>
  <section>
    <h2>Overview</h2>
    <p>A schema defines the storage structure of a relational database.
    A schema MUST have a name. The origin of the page and the schema name
    together uniquely identify a database instance during runtime.</p>

    <p>A schema has a referential version number associated with it. Version
    number is an integer greater than zero and can be freely assigned. It has
    no effect on identifying a database. It is provided for the convenience of
    developers to version their schema without extra table.</p>

    <p>A schema is structured in a hierachical way. A database schema contains
    one or more tables. A table contains one or more columns, zero or more
    indices, and zero or more constraints. The collection of columns in a table
    defines the fields carried by a row, which is the fundamental unit of data
    storage in relational database. Each column consists a name and an
    associated data type. The indices hint the database engine to build index
    structures so that subsequent queries can be acclerated. Index definitions
    MAY be honored if the database engine determined that they are necessary.
    The constraints define the relations of rows and ensures data integrity,
    and MUST be honored.</p>

    <p>The database schema can be described in JSON format or constructed via
    builder pattern APIs. Schema can be changed through schema queries within
    any <code>readwrite</code> transactions. The JSON format and related APIs
    are described in the following sections.</p>
  </section>

<section>
  <h2>Naming Rules</h2>
  <p>Names in schema means identifiers used to identify an entity, such as
  database, table, column, index, constraint, and so on. All names used in the
  database schema MUST abide the following rules:</p>
  <ul>
    <li>Names are case sensitive</li>
    <li>A name MUST pass the following check:
        <code>/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)</code>
    </li>
    <li>A name MUST NOT conflict with properties and methods defined in
        <code>Object.prototype</code> and <a>ITable</a>.
    </li>
  </ul>
</section>

<section>
  <h2>Column Types</h2>
  <p>All columns in a table schema MUST be associated with a given type. Valid
  types of a column are defined in <code>ColumnType</code></p>
  <pre class="idl">
    enum ColumnType {
      // ArrayBuffer
      "blob",

      "boolean",
      "date",
      "number",
      "string",
      "object"
    };

    typedef (ArrayBuffer or boolean or Date or number or DOMString or object) ValueType;
    typedef (boolean or Date or number or DOMString) IndexableValueType;
  </pre>

  <p>Only some value types are <dfn>indexable</dfn>, which means that they can 
  be compared, sorted, and used in indices and predicates. Non-indexable types,
  <code>blob</code> and <code>object</code>, MUST NOT be used to create indices
  and predicates, except the <code>isNull()</code> and <code>isNotNull()</code>
  predicates.</p>
</section>

<section>
  <h2>Orders</h2>
  <p>There are two sorting orders defined in the following enum:</p>
  <pre class="idl">
    enum Order {
      // Represents ascending sort order (Default).
      "asc",

      // Represents descending sort order.
      "desc"
    };
  </pre>
  <p>Ascending sort order is the natural sort order, which means that if two
  fields are ordered as <code>a, b</code>, then <code>(a <= b) === true</code>.
  <code>blob</code> and <code>object</code> types are not <a>indexable</a>,
  which implied they were not comparable and thus the orders have no effect for
  these two types.</p>
</section>

<section>
  <h2>Schema Definition JSON Format</h2>
  <p>Database schema can be defined using a single dictionary object. The
  following example demonstrates how to create a database using such object.</p>
  <pre class="example highlight">
// Create a database using predefined JSON schema.
var hrSchema = {
  'name': 'hr',
  'version': 2,
  'table': [
    {
      'name': 'Dept',
      'column': [
        {'name': 'id', 'type': 'string'},
        {'name': 'name', 'type': 'string', 'notNull': true}
      ],
      'constraint': {
        'primaryKey': 'id'
      }
    },
    {
      'name': 'Emp',
      'column': [
        {'name': 'id', 'type': 'number'},
        {'name': 'name', 'type': 'string'},
        {'name': 'deptId', 'type': 'string'},
        {'name': 'title', 'type': 'string'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id', 'order': 'desc'}],
        'foreignKey': [{
          'name': 'fk_DeptId',
          'local': 'deptId',
          'remote': 'Dept.id',
          'action': 'restrict',
          'timing': 'immediate'
        }],
        'unique': [{
          'name': 'uq_Name',
          'column': [{'name': 'name', 'order': 'desc'}]
        }],
        'notNull': ['id', 'name', 'deptId']
      },
      'index': [
        {
          'name': 'idx_Title',
          'column': [{'name': 'title', 'order': 'asc'}]
        }
      ]
    }
  ]
};

var db;
navigator.db.open('hr').then(function(connection) {
  db = connection;
  var version = db.schema().version;
  if (version == 0) {
    return db.create(hrSchema).commit();
  }
  return Promise.resolve();
}).then(function() {
  // Database created, do something here.
});

  </pre>

  <p>Any violation of the rules described in this section will result in
  <a>InvalidSchemaError</a> exception. Any name not obeying
  <a href="#naming-rules">Naming Rules</a> will also result in
  <a>InvalidSchemaError</a> exception.</p>

  <p>The following WebIDL defines <code>Schema</code> dictionary type.
  <pre class="idl">
    dictionary Schema {
      DOMString name;
      unsigned short version = 1;
      TableSpec[] table;
    };
  </pre>
  <dl class="dictionary-members">
    <dt><code>name</code></dt>
    <dd>Name of the database.</dd>
    <dt><code>version</code></dt>
    <dd>Version of the database, for reference only.</dd>
    <dt><code>table</code></dt>
    <dd>Array of <a href="#table-specifications">table specifications</a>, and
    it MUST NOT be empty.</dd>
  </dl>

  <section>
    <h2>Table Specifications</h2>
    <p>The following WebIDL defines table specification dictionary type.</p>
    <pre class="idl">
      dictionary TableSpec {
        DOMString name;
        ColumnSpec[] column;
        ConstraintSpec? constraint;
        IndexSpec[]? index;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the table, MUST be unique within the database.</dd>
      <dt><code>column</code></dt>
      <dd>Array of <a href="#column-specifications">column specifications</a>,
      and it MUST NOT be empty.</dd>
      <dt><code>constraint</code></dt>
      <dd>(Optional)
      <a href="#constraint-specifications">Constraint specifications</a>.</dd>
      <dt><code>index</code></dt>
      <dd>(Optional) Array of
      <a href="#index-specifications">index specifications</a>, and it MUST NOT
      be empty when specified.</dd>
    </dl>
  </section>

  <section>
    <h2>Column Specifications</h2>
    <p>The following WebIDL defines column specification dictionary type:</p>
    <pre class="idl">
      dictionary ColumnSpec {
        DOMString name;
        ColumnType type;
        boolean notNull = false;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the column, MUST be unique within the containing table.</dd>
      <dt><code>type</code></dt>
      <dd>Associated column type of the column.</dd>
      <dt><code>notNull</code></dt>
      <dd>When specified as <code>true</code>, the column is <a>NOT NULL</a>.
      </dd>
    </dl>
    <p><dfn>NOT NULL</dfn> means the column MUST NOT have a value of
    <code>undefined</code> or <code>null</code>.</p>
    <p>A column has a <dfn>canonical name</dfn>, which is represented as
    <code>&lt;containing table name&gt;.&lt;column name&gt;</code>. One can
    <dfn>refer</dfn> to a column by its name, if the referral is happened
    within the table scope; or by its <a>canonical name</a> from anywhere
    within the database.</p>
  </section>

  <section>
    <h2>Index Specifications</h2>
    <p>The following WebIDL defines index specification dictionary type:</p>
    <pre class="idl">
      typedef (DOMString or DOMString[] or IndexedColumnSpec[]) IndexedColumnDefinition;
      dictionary IndexSpec {
        DOMString name;
        IndexedColumnDefinition column;
        IndexType type = "btree";
        boolean unique = false;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the index, MUST be unique within the containing table.</dd>
      <dt><code>column</code></dt>
      <dd>Indexed column definitions. If provided as
          <code>DOMString</code>, the string MUST <a>refer</a> to an
          <a>indexable</a> column of the containing table; if provided as
          <code>DOMString[]</code>, it MUST NOT be empty, and the strings MUST
          <a>refer</a> to different <a>indexable</a> columns of the containing
          table. In these two cases, default sort order of <code>asc</code> is
          used. If provided as <code>IndexedColumnSpec[]</code>, it MUST NOT
          be empty, and each <code>IndexedColumnSpec</code> MUST <a>refer</a>
          to different column.</dd>
      <dt><code>type</code></dt>
      <dd>(Optional) Type of index, default to <code>btree</code></dd>
      <dt><code>unique</code></dt>
      <dd>(Optional) Keys in index shall be unique or not,
          default to <code>false</code>.</dd>
    </dl>
    <p>Index type allows user to hint the query engine to create an index on
    specified columns in given sorting orders. The query engine MAY construct
    the index, MAY follow the given sorting orders, and MAY use the specified
    type. The query engine can refuse to construct the index as specified, or
    construct a different index.</p>

    <p>The index type is an enum:</p>
    <pre class="idl">
      enum IndexType {
        // B+ Tree index.
        "btree",

        // Hash index.
        "hash"
      };
    </pre>

    <p>An index can be keyed by one or more columns. A <dfn>unique key</dfn>
    means that the value or combination of values used as index key is unique
    within the index. By default, all indices allow duplicate keys unless the
    <code>unique</code> is set to true. A <a>ConstraintError</a> will be thrown
    if user tried to insert/update a row with duplicated key when a unique
    index is specified.</p>

    <p>The WebIDL below defines indexed column specification.</p>
    <pre class="idl">
      dictionary IndexedColumnSpec {
        DOMString name;
        Order order = "asc";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the indexed column, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>order</code></dt>
      <dd>(Optional) Sorting order of the column, default to
          <code>asc</code>.</dd>
    </dl>
    <p>If an index definition overlapped with implicit indices created by
    constraints (for example, create an index on the same column of the primary
    key), it will be up to the query engine to determine whether or not to
    create this index.</p>
  </section>

  <section>
    <h2>Constraint Specifications</h2>
    <p>The following WebIDL defines constraint specification.</p>
    <pre class="idl">
      typedef (DOMString or DOMString[] or IndexedColumnSpec[] or PrimaryKeySpec) PrimaryKeyDefinition;
      dictionary ConstraintSpec {
        PrimaryKeyDefinition? primaryKey;
        ForeignKeySpec? foreignKey;
        UniqueSpec? unique;
        (DOMString or DOMString[])? notNull;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>primaryKey</code></dt>
      <dd>(Optional) <a href="#primary-key-specification">Primary key
      specification</a>.</dd>
      <dt><code>foreignKey</code></dt>
      <dd>(Optional) <a href="#foreign-key-specification">Foreign key
      specification</a>.</dd>
      <dt><code>unique</code></dt>
      <dd>(Optional) <a href="#unique-index-specification">Unique index
      specification</a>.</dd>
      <dt><code>notNull</code></dt>
      <dd>(Optional) Column(s) that are <a>NOT NULL</a>.</dd>
    </dl>
    <p>The name(s) specified in the notNull MUST <a>refer</a> to column(s)
    of the containing table. When provided as <code>DOMString[]</code>, the
    array MUST NOT be empty, and they MUST <a>refer</a> to different
    columns.</p>
  </section>

  <section>
    <h2>Unique Index Specification</h2>
    <p>Unique index is a specialized index that disallows duplicated keys.
    Its definition format is the same as index definition. If two or more
    columns are defined as keys, the combination of the column values forms the
    uniqueness.</p>
    <pre class="idl">
      dictionary UniqueSpec {
        DOMString name;
        IndexedColumnDefinition column;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the index, MUST be unique within the containing table.</dd>
      <dt><code>column</code></dt>
      <dd>Same as the <code>column</code> in <a href="#index-specifications">
      Index Specifications</a>.</dd>
    </dl>
  </section>

  <section>
    <h2>Primary Key Specification</h2>
    <p>Primary key is a specialized unique index. Each table can have only one
    primary key. A primary key can be specified using unique index
    specification, or use the following WebIDL:</p>
    <pre class="idl">
      dictionary PrimaryKeySpec {
        DOMString name;
        boolean autoIncrement;
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt><dd>Column name of the primary key, MUST
      <a>refer</a> to <a>indexable</a> column of the containing table.</dd>
      <dt><code>autoIncrement</code></dt><dd>Create auto-increment
      primary key.</dd>
    </dl>
    <p>When the autoIncrement field is specified, the specified column MUST be
    of type <code>Number</code>. An auto-increment key will start from zero.
    When a new row is inserted into the table, the key will increase by one and
    assigned to that row regardless the original key value given to the
    row.</p>
    <p class="note">Unlike SQL, primary key does not have name.</p>
  </section>

  <section>
    <h2>Foreign Key Specification</h2>
    <p>The following WebIDL defines foreign key specification.</p>
    <pre class="idl">
      dictionary ForeignKeySpec {
        DOMString name;
        DOMString local;
        DOMString remote;
        ForeignKeyAction action = "restrict";
        ForeignKeyTiming timing = "immediate";
      };
    </pre>
    <dl class="dictionary-members">
      <dt><code>name</code></dt>
      <dd>Name of the foreign key, MUST be unique withing the containing table.
      </dd>
      <dt><code>local</code></dt>
      <dd>Referring column name, MUST <a>refer</a> to an <a>indexable</a>
      column of the containing table.</dd>
      <dt><code>remote</code></dt>
      <dd>Referred column <a>canonical name</a>, MUST <a>refer</a> to an
      <a>indexable</a> column.</dd>
      <dt><code>action</code></dt>
      <dd>(Optional) Foreign key action, default to <code>restrict</code>.</dd>
      <dt><code>timing</code></dt>
      <dd>(Optional) Foreign key timing, default to <code>immediate</code>.
      </dd>
    </dl>
    <p>A <dfn>chainned foreign key</dfn> means the <code>remote</code> column
    is also a <code>local</code> column of another foreign key, which forms a
    dependency. The query engine MAY support chainned foreign key. The query
    engine MAY support referred column to be within the containing table.</p>

    <p>Foreign key actions are enum values as defined in the following:</p>
    <pre class="idl">
      enum ForeignKeyAction {
        // Any constraint violation results in cancelling the operation that
        // violated the constraint.
        "restrict",

        // Constraint violation results in modifying related tables as
        // necessary to maintain data integrity.
        "cascade"
      };
    </pre>
    <p>Foreign key timings are enum values as defined below:</p>
    <pre class="idl">
      enum ForeignKeyTiming {
        // The constraint is enforced right before a transaction is committed.
        // The constraint can be violated by individual queries during the
        // lifetime of the enclosing transaction, without any error being
        // thrown.
        "deferrable",

        // The constraint is enforced during execution of each individual query.
        "immediate"
      };
    </pre>
  </section>

</section>

<section>
  <h2>Schema Query</h2>
  <p>A database instance is created using schema queries. The associated schema
  of the database can also be altered using schema queries. Schema queries are
  run in the context of <a>transaction</a> and can be executed any time during
  the life time of the database.</p>

  <section>
    <h2>Database-Level Schema Query</h2>
    <p>The <code>ISchemaQueryProvider</code> is the interface of manipulating
    database-level schema:</p>
    <pre class="idl">
      interface ISchemaQueryProvider {
        IExecutionContext exportSchema();
        IExecutionContext create(Object schema);
        IExecutionContext setVersion(unsigned short version);
        IExecutionContext setForeignKeyCheck(boolean value);
        IDatabaseSchema schema();
        ITableBuilder createTable();
        ITableChanger alterTable();
        IExecutionContext dropTable(DOMString name);
      };
    </pre>
    <dl class="methods">
      <dt><code>IExecutionContext exportSchema();</code></dt>
      <dd>Export schema object, MUST be run in the context of a
      <a>transaction</a>.</dd>
      <dt><code>IExecutionContext create(Object schema);</code></dt>
      <dd>Create database schema from provided schema object, MUST be run in
      the context of a <a>transaction</a>. The schema object MUST conform to
      the format defined in <a href="#schema-definition-json-format">
      Schema Definition JSON Format</a>. Any error in the schema will result in
      transaction failure with <a>InvalidSchemaError</a>.</dd>
      <dt><code>IExecutionContext setVersion(unsigned short version);</code>
      </dt>
      <dd>Sets the version number of the schema, MUST be run in the context of
      a <a>transaction</a>.</dd>
      <dt><code>IExecutionContext setForeignKeyCheck(boolean value);</code></dt>
      <dd>Enables or disables foreign key constraint enforcement within the
      transaction that the execution context returned by this function is in.
      Misuse of this function MAY cause broken data integrity.
      </dd>
      <dt><code>IDatabaseSchema schema();</code></dt>
      <dd>Returns an <code>IDatabaseSchema</code> object for crafting data
      manipulation queries.</dd>
      <dt><code>ITableBuilder createTable();</code></dt>
      <dd>Returns a <a href="#table-builder">table builder</a> for creating a
      new table.</dd>
      <dt><code>ITableChanger alterTable(string tableName);</code></dt>
      <dd>Returns a <a href="#table-changer">table changer</a> for altering an
      existing table. The table referred by <code>tableName</code> MUST already
      exist in the database, otherwise a <a>DataError</a> will be raised.</dd>
      <dt><code>IExecutionContext dropTable(DOMString name);</code></dt>
      <dd>Removes a table and all its rows from database. The table referred by 
      <code>name</code> MUST already exist in the database, otherwise a
      <a>DataError</a> will be raised.</dd>
    </dl>
  </section>
  <section>
    <h2>Database Schema</h2>
    <p>Database schema obtained from <code>ISchemaQueryProvider.schema()</code>
    provides <code>IDatabaseSchema</code> interface.</p>
    <pre class="idl">
      interface IDatabaseSchema {
        readonly attribute DOMString name;
        readonly attribute unsigned short version;
        ITable table(DOMString tableName);
      };
    </pre>
    <dl class="attributes">
      <dt><code>DOMString name</code></dt>
      <dd>Name of the database.</dd>
      <dt><code>unsigned short version</code></dt>
      <dd>Version of the database schema.</dd>
    </dl>
    <dl class="methods">
      <dt><code>ITable table(DOMString tableName);</code></dt>
      <dd>Returns a read-only object that implements <a>ITable</a> interface,
      whose members are <a>IColumn</a> objects representing columns in the
      specified table. The table referred by <code>tableName</code> MUST
      already exist in the database, otherwise a <a>DataError</a> will be
      raised.</dd>
    </dl>
  </section>

  <section>
    <h2>Table Builder</h2>
    <p>Table builder is used to describe the new table that will be created,
    and MUST be used within the context of a <a>transaction</a>.</p>
    <pre class="idl">
      interface ITableBuilder : IExecutionContext {
        ITableBuilder column(DOMString name, ColumnType type, optional boolean notNull = false);
        ITableBuilder primaryKey(PrimaryKeyDefinition primaryKey);
        ITableBuilder foreignKey(ForeignKeySpec foreignKey);
        ITableBuilder unique(DOMString name, IndexedColumnDefinition columns);
        ITableBuilder index(DOMString name, IndexedColumnDefinition columns);
      };
    </pre>
    <p>All methods returns the same <code>ITableBuilder</code> object that
    they were called from to make cascade builder pattern possible. If any of
    the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times except <code>primaryKey</code>.</p>
    <dl class="methods">
      <dt><code>ITableBuilder column(DOMString name, ColumnType type, optional boolean notNull = false);</code></dt>
      <dd>Adds a column to table. <code>name</code> MUST be unique within the
      containing table.</dd>
      <dt><code>ITableBuilder primaryKey(PrimaryKeyDefinition primaryKey);</code></dt>
      <dd>Adds a primary key to table. This method MUST NOT be called multiple
      times.</dd>
      <dt><code>ITableBuilder foreignKey(ForeignKeySpec foreignKey);</code></dt>
      <dd>Adds a foreign key to table.</dd>
      <dt><code>ITableBuilder unique(DOMString name, IndexedColumnDefinition columns);
</code></dt>
      <dd>Adds an unique index to table. The <code>name</code> is the name of
      the index, and it MUST be unique within the containing table.</dd>
      <dt><code>ITableBuilder index(DOMString name, IndexedColumnDefinition columns);
</code></dt>
      <dd>Adds an index to table. The <code>name</code> is the name of the
      index, and it MUST be unique within the containing table.</dd>
    </dl>
  </section>

  <section>
    <h2>Table Changer</h2>
    <p>Table changer is used to change the schema of an existing table, and
    MUST be used within the context of a <a>transaction</a>. If the table
    already contains data, altering table schema can cause constraint
    violations and fail the transaction.</p>
    <pre class="idl">
      interface ITableChanger : IExecutionContext {
        ITableChanger rename(DOMString newTableName);
        ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);
        ITableChanger dropColumn(DOMString name);
        ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);
        ITableChanger dropPrimaryKey();
        ITableChanger addForeignKey(ForeignKeySpec foreignKey);
        ITableChanger addUnique(DOMString name, IndexedColumnDefinition columns);
        ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);
        ITableChanger dropConstraintOrIndex(DOMString name);
        IColumnChanger setColumn(DOMString name);
      };
    </pre>
    <p>All methods returns the same <code>ITableChanger</code> object that
    they were called from to make cascade builder pattern possible, except that
    <code>setColumn</code> will return a <a>IColumnChanger</a> instead. If any
    of the rule described in the following table were violated, an
    <a>InvalidSchemaError</a> will be thrown. All methods can be called
    multiple times.</p>
    <dl class="methods">
      <dt><code>ITableChanger rename(DOMString newTableName);</code></dt>
      <dd>Renames the table, <code>newTableName</code> MUST be unique within the
      database, and MUST NOT be the same as existing table name.</dd>
      <dt><code>ITableChanger addColumn(DOMString name, ColumnType type, optional boolean notNull = false, optional ValueType defaultValue = null);</code></dt>
      <dd>Adds a new column to table, <code>name</code> MUST be unique within
      the containing table. If <code>defaultValue</code> is given, it MUST
      be of the same type as specified in <code>type</code>. Every existing row
      in the table will be added a new column with </code>defaultValue</code>.
      </dd>
      <dt><code>ITableChanger dropColumn(DOMString name);</code></dt>
      <dd>Removes a column from table. The <code>name</code> MUST <a>refer</a>
      to an existing column in the table schema. The referred column MUST NOT
      be the only column in the table schema, and MUST NOT be referred by any
      index nor constraints. Every existing row in the table will be modified
      to remove the field represented by that column.</dd>
      <dt><code>ITableChanger addPrimaryKey(PrimaryKeyDefinition primaryKey);</code></dt>
      <dd>Adds a primary key to table, the table MUST not have existing primary
      key.</dd>
      <dt><code>ITableChanger dropPrimaryKey();</code></dt>
      <dd>Removes primary key from table. If the table does not have primary
      key, this method will do nothing.</dd>
      <dt><code>ITableChanger addForeignKey(ForeignKeySpec foreignKey);</code></dt>
      <dd>Adds a foreign key to the table.</dd>
      <dt><code>ITableChanger addUnique(DOMString name, IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an unique index to the table. The <code>name</code> is the name
      of the unique index and MUST be unique within the containing table.</dd>
      <dt><code>ITableChanger addIndex(DOMString name, IndexedColumnDefinition columns);</code></dt>
      <dd>Adds an index to the table. The <code>name</code> is the name
      of the index and MUST be unique within the containing table.</dd>
      <dt><code>ITableChanger dropConstraintOrIndex(DOMString name);</code></dt>
      <dd>Removes a constraint or index in table by name. The <code>name</code>
      MUST refer to an existing constraint or index.</dd>
      <dt><code>IColumnChanger setColumn(DOMString name);</code></dt>
      <dd>Changes a column in the table, and the <code>name</code> MUST
      <a>refer</a> to an existing column in the table schema.</dd>
    </dl>
  </section>

  <section>
    <h2>Column Changer</h2>
    <pre class="idl">
      interface IColumnChanger {
        ITableChanger set(DOMString newColumnName, optional boolean notNull = true);
      };
    </pre>
    <dl class="methods">
      <dt><code>ITableChanger set(DOMString newColumnName, optional boolean notNull = true);</code></dt>
      <dd>Changes the column's name or <a>NOT NULL</a> property. The returned
      <code>ITableChanger</code> is the parent object that creates this object.
      </dd>
      <p class="note">Changing column data type is not supported by this spec.
      JavaScript is famous of tricky type conversions and it is unlikely to
      have conversion rules that covers every corner case.</p>
    </dl>
  </section>

  <section class="informative">
    <h2>Schema Query Examples</h2>
    <p>The following example demonstrates how to create a database schema.</p>
    <pre class="example highlight">
var db;
var tx = db.createTransaction('readwrite');
var q1 = db.createTable('Dept')
           .column(/* column_name */ 'id',
                   /* column_type */ 'string',
                   /* not_null */ true)
           .column('name', 'string', true)
           .primaryKey([{'name': 'id'}]);

var q2 = db.createTable('Emp')
           .column('id', 'number', true)
           .column('name', 'string', true)
           .column('deptId', 'string', true)
           .column('title', 'string')
           .primaryKey([{'name': 'id', 'order': 'asc'}])
           .unique(['name'])
           .index('idx_Desc', [{'name': 'desc', 'order': 'asc'}])
           .foreignKey({
             'name': 'fk_DeptId',
             'local': 'deptId',
             'remote': 'Dept.id',
             'action': 'restrict',
             'timing': 'immediate'
           });

tx.exec([q1, q2]).then(function() {
  // Table created, do something here.
});

    </pre>
    <p>The following example shows how to alter database schema during schema
    upgrade.</p>
    <pre class="example highlight">
var db;
var version = db.schema().version();

if (version < 2) {
  // Need DB upgrade.
  var tx = db.createTransaction('readwrite');
  var q1 = db.setVersion(2);
  var q2 = db.createTable('NewTable')
             .column('id', 'string', true)
             .column('name', 'string', true);
  var q3 = db.alterTable('Emp')
             .addColumn('location', 'string', true, 'LAX')
             .setColumn('title').set('title', true)  // Change to NOT NULL
             .addIndex('idx_location', 'location');
  var q4 = db.dropTable('Foo');
  tx.exec([q1, q2, q3, q4]).then(function() {
    // Update data after schema has changed.
  });
}

    </pre>
  </section>
</section>


</section>

<section>
  <h2>Database</h2>

<section>
  <h2>Overview</h2>
  <p>A database's origin is the same as the origin of the document or worker.
  Each origin has an associated set of database.</p>

  <p class="note">The database origin is not affected by changes to
  <code>document.domain</code>.</p>

  <p>Every database has a predefined layout of the data structures persisted,
  which is referred as <a href="#schema">schema</a>. The <em>database name</em>
  specified in schema identifies the database within a specific origin.
  The name MUST satisfy the <a href="#naming-rules">Naming Rules</a>, and stay
  constant for the lifetime of the database. Each database also has a version
  number for reference only.</p>

  <p>Databases has a <em>delete pending</em> flag which is used during
  deletion. When a database is requested to be deleted the flag is set to true
  and all attempts at opening the database are stalled until database is
  deleted.</p>

  <p>The act of opening a database creates a <a>connection</a>. There MAY
  be multiple connections to a given <code>persistent</code> database at any
  given time, where <code>temporary</code> database accepts only one connection.
  Each connection has a <em>closePending</em> flag which initially is set to
  false.</p>

  <p>When a connection is initially created it is in opened state. The
  connection can be closed through several means. If the connection is garbage
  collected or execution context where the connection is created is destroyed
  (for example due to the user navigating away from that page), the connection
  is closed. The connection can also be closed explicitly via API. When the
  connection is closed the closePending flag is always set to true if it
  hasn't already been. All uncommitted transactions will be canceled if their
  associated connections are marked close pending.</p>

  <p>Users can create observers associated with a given database. Each
  observer consists a select query. When the results of that select query
  change, the observer will be triggered. The change MAY come from other
  connections. When the connection associated with a registered observer is
  marked as close pending, the observer MUST be unregistered automatically.</p>
</section>

<section>
  <h2>Relational Database</h2>
  <p>The relational database is part of <code>Navigator</code> as defined in
  following WebIDL.</p>
  <pre class="idl">
    partial interface Navigator {
      readonly attribute IRelationalDatabase db;
    };
  </pre>

  <p>The relational database is defined by the following WebIDL.</p>
  <pre class="idl">
    interface IRelationalDatabase {
      readonly attribute IDatabaseFunctionProvider fn;

      Promise< DatabaseConnection > open(DOMString name, OpenDatabaseOptions? opt);
      Promise< void > drop(DOMString name);
    };
  </pre>
  <dl class="attributes">
    <dt><code>IDatabaseFunctionProvider fn</code></dt>
    <dd>Provides a namespace for <a href="#aggregation-functions">aggregation
    functions</a> that can be used in queries.</dd>
  </dl>
  <dl class="methods">
    <dt><code>Promise< DatabaseConnection > open(DOMString name, OpenDatabaseOptions? opt)</code></dt>
    <dd>Opens a database connection using provided name. If the database does
    not exist, create a new database instance and returns connection to it.
    If the database is marked delete pending, the promise will be rejected with
    <a>BlockingError</a>. If the <code>OpenDatabaseOptions</code> is not
    specified, a <code>persistent</code> database with the given name will be
    opened/created.</dd>
    <dt><code>Promise< void > drop()</code></dt>
    <dd>Deletes a database using provided <code>name</code>. This MUST follow
    the <a href="#delete-database-algorithm">delete database algorithm</a>. If
    the database does not exist, the returned promise will resolve immediately.
    If the database is marked delete pending, the promise will resolve
    immediately.</dd>
    <dt><code>IBindableValue bind(unsigned short index);</code></dt>
    <dd>Provides a bind-able value that can be used to construct parameterized
    queries.</dd>
  </dl>

  <p>Open database options are specified as a dictionary object.</p>
  <pre class="idl">
    dictionary OpenDatabaseOptions {
      RDBStorageType storageType;
    };
  </pre>

  
  The <code>RDBStorageType</code> is an enum:
  <pre class="idl">
    enum RDBStorageType {
      // Data will be persisted in permanent storage.
      "persistent",

      // Data will be persisted in memory only.
      "temporary"
    };
  </pre>

  <p>When <code>storageType</code> is set to <code>temporary</code>, the
  relational database acts as in-memory cache of data and offers only the
  relational query capability. The <code>storageType</code> is fixed for the
  lifetime of returned database connection.</p>

  <section>
    <h2>Delete Database Algorithm</h2>
    <p>The delete database algorithm is performed in following steps:</p>
    <ol>
      <li>Marks this database as delete pending.</li>
      <li>Marks each connection to this database as close pending, which will
      effectively prevent new transactions from creating.</li>
      <li>Waits for all pending transactions to be cancelled.</li>
      <li>Closes all connections.</li>
      <li>Deletes the database.</li>
      <li>Resolves the promise.</li>
    </ol>
  </section>
</section>

<section>
  <h2>Connection</h2>
  <p>The database <dfn>connection</dfn> is the means by which the browser
  session and underlying database communicate with each other. The following
  is the main interface of a database connection:</p>

  <pre class="idl">
    interface IDatabaseConnection {
      ITransaction createTransaction(optional TransactionMode mode = "readonly");
      Promise< void > close();
      IBindableValue bind(unsigned short index);
    };
  </pre>
  <dl class="methods">
    <dt><code>ITransaction createTransaction(optional TransactionMode mode = "readonly");</code></dt>
    <dd>Creates an explicit transaction. If the connection is marked as close
    pending, throws <a>BlockingError</a>.</dd>
    <dt><code>Promise< void > close();</code></dt>
    <dd>Closes the connection. The promise will resolve if and only if all
    scheduled transactions are finished. The connection will be marked as
    close pending immediately after this call, and no more new transaction
    can be created within this connection.</dd>
    <dt><code>IBindableValue bind(unsigned short index);</code></dt>
    <dd>Returns a bindable value that can be used in parameterized query.</dd>
  </dl>

  <p>The actual database connection returned from <code>Navigator</code> is a
  class object that implements four different interfaces.</p>
  <pre class="idl">
    interface DatabaseConnection : IDatabaseConnection {
      readonly attribute DOMString name;
    };
    DatabaseConnection implements IDatabaseObserver;
    DatabaseConnection implements IDataQueryProvider;
    DatabaseConnection implements ISchemaQueryProvider;
  </pre>
  <dl class="attributes">
    <dt><code>name</code></dt>
    <dd>Name of the database. It MUST be the same as the <code>name</code>
    field specified in schema.</dd>
  </dl>
  <p>The <a>ISchemaQueryProvider</a> provides
  <a href="#database-level-schema-query">database-level schema query</a> and
  allows creating or changing the database schema. The
  <a>IDataQueryProvider</a> provides APIs to construct
  <a href="#data-manipulation-query">data manipulation query</a> to be used
  to manipulate data within a transaction. The <a>IDatabaseObserver</a>
  provides change observation for the results of a select query, regardless
  the changes are from this connection or not.</p>
</section>

<section>
  <h2>Transaction</h2>
  <p>A <dfn>transaction</dfn> is an atomic unit of reading and writing data in
  a database. The term atomic means it is guaranteed that all operations inside
  this transaction to be committed as a whole, or none get committed.
  A committed transaction guarantees all data being written to storage.
  The operations inside a transaction are referred as queries. A
  <dfn>query</dfn> means an interaction with the database: data retrieval,
  data persistence, or change of schema.</p>
  
  <p>Transaction execution behavior is modeled as the following:</p>

  <pre class="idl">
    typedef (void or object[]) TransactionResults;

    interface IExecutionContext {
      Promise< TransactionResults > commit();
      Promise< void > rollback();
    };
  </pre>
  <dl class="methods">
    <dt><code>Promise< TransactionResults > commit();</code></dt>
    <dd>Runs <a href="#commit-algorithm">commit algorithm</a>.</dd>
    <dt><code>Promise< void > rollback();</code></dt>
    <dd>Runs <a href="#rollback-algorithm">rollback algorithm</a>.</dd>
  </dl>

  <p>All transactions are associated with a database connection, which is the
  <a>connection</a> that the transaction is created within. A transaction has
  a predetermined <em>mode</em> to indicate what access this transaction is
  asking for. The mode is set when the transaction is created and remains fixed
  for the life of the transaction. There are two transaction modes:</p>

  <pre class="idl">
    enum TransactionMode {
      // Transaction intends to read data/schema only.
      "readonly",

      // Transaction intends to read/write data and/or read/change schema.
      "readwrite"
    };
  </pre>

  <p>A transaction has a <dfn>scope</dfn> that determines the rows affected by
  this transaction. The scope is automatically calculated. The scope of a
  transaction MAY dynamically change during the lifetime of the transaction.
  </p>

  <p>A transaction can be created explicitly or implicitly. An explicit
  transaction is created directly from
  <code>IDatabaseConnection.createTransaction()</code>. An implicit transaction
  is created when the <a href="#commit-algorithm">commit algorithm</a> needs
  one. The explicit transaction is modeled as following:</p>

  <pre class="idl">
    interface ITransaction : IExecutionContext {
      Promise< void > begin();
      Promise< TransactionResults > exec(IExecutionContext[] queries);
      Promise< TransactionResults > attach(IExecutionContext query);
    };
  </pre>
  <dl class="methods">
    <dt><code>Promise< void > begin();</code></dt>
    <dd>Starts <em>sequence mode</em> execution.</dd>
    <dt><code>Promise< TransactionResults > exec(IExecutionContext[] queries);</code></dt>
    <dd>Starts <em>batch mode</em> execution and auto-commit.</dd>
    <dt><code>Promise< TransactionResults > attach(IExecutionContext query);</code></dt>
    <dd>Schedules a query to existing <em>sequence mode</em> execution. The
    promise will be resolved with the results when the query is executed.
    The query MUST NOT be an explicit transaction, i.e. <a>ITransaction</a>
    object.</dd>
  </dl>

  <p class="note">This specification does not support nested transactions.</p>

  <p>The lifetime of an explicit transaction is controlled by the user.
  There are two ways to start execution: <em>batch mode</em> and
  <em>sequence mode</em>. In batch mode, an explicit transaction is started
  with <code>exec(queriesArray)</code> and returns
  a result <code>Promise</code>. All queries will be executed sequentially in
  the order received, and the results of last query in the transaction are
  returned in the promise. In sequence mode, user calls <code>begin()</code> to
  start the transaction, calls <code>attach(query)</code> to attach a query to
  the transaction's execution context. The user can call <code>commit()</code>
  to indicate the end of transaction, and a final result <code>Promise</code>
  will be returned; or the user can call <code>rollback()</code> to abort the
  transaction, and all modifications done by previous attached queries will be
  discarded.</p>

  <p>When a transaction is committed or rolled back, it is said to be
  <em>finished</em>. A finished transaction MUST NOT be started nor rolled
  back. If a transaction's connection is lost before transaction being
  finished, the transaction is effectively rolled back and no change will be
  persisted.</p>

  <section>
    <h2>Commit Algorithm</h2>
    <p>An <a>IExecutionContext</a> can be obtained from <a>ITransaction</a>, or
    other classes such as <a>IQuery</a> or <a>ITableBuilder</a>. The execution
    context from <a>ITransaction</a> is a <em>bound context</em>, which means
    that it has an associated transaction. An execution context from sources
    other than <a>ITransaction</a> is an <em>unbound context</em>, which means
    that it does not have an associated transaction.</p>

    <p>The commit algorithm is described in following steps:</p>
    <ol>
      <li>If the execution context is a bound context, go to step 3.</li>
      <li>If the context can be carried out using <code>readonly</code>
      transaction mode, create a transaction using that mode; otherwise create
      a <code>readwrite</code> transaction. Associate the transaction with the
      execution context.</li>
      <li>If the associated transaction is marked as <em>pending finish</em>,
      throws <a>TransactionStateError</a>.
      <li>Mark the associated transaction as <em>pending finish</em>, which
      will prohibit the transaction from attaching more queries, or calling
      <code>rollback</code>.
      <li>Retrieves the result promise <code>R</code> of the last execution
      context in the associated transaction from query engine.</li>
      <li>If the transaction is already running in sequence mode, returns
      <code>R</code>.</li>
      <li>If the associated transaction is not started, notifies the query
      engine to execute it in batch mode, and returns <code>R</code>.</li>
      <li>When <code>R</code> resolves or rejects, mark transaction as
      <em>finished</em>.</li>
    </ol>
  </section>

  <section>
    <h2>Rollback Algorithm</h2>
    <p>The rollback algorithm is described in following steps:</p>
    <ol>
      <li>If the execution context is an unbound context, returns a resolved
      promise.</li>
      <li>If the associated tranaction is marked as <em>pending finish</em> or
      <em>finished</em>, throws <a>TransactionStateError</a>.</li>
      <li>If the associated transaction is not executed yet, mark the
      transaction as <em>finished</em> and returns a resolved promise.</li>
      <li>Marks the associated transaction as <em>finish pending</em>, and
      notifies query engine to rollback. Returns a promise.</li>
      <li>When the query engine rolled back the transaction, resolve promise;
      otherwise, reject promise with <a>IntegrityError</a>.</li>
    </ol>
  </section>
</section>

<section>
  <h2>Observers</h2>
  <p>Observers monitor row changes inside a database. If the results from
  registered query change due to data changes in the database, the callback in
  corresponding observer will be invoked. Observer management are performed
  via the following interface:</p>

  <pre class="idl">
    callback observerCallback = void ();

    interface IDatabaseObserver {
      DOMString observe(ISelectQuery query, observerCallback callbackFn);
      void unobserve(DOMString observerKey);
    };
  </pre>
  <dl class="methods">
    <dt><code>DOMString observe(ISelectQuery query, observerCallback callbackFn);</code></dt>
    <dd>Registers a select query for observation, returns a unique observer key
    within the connection.</dd>
    <dt><code>void unobserve(DOMString observerKey);</code></dt>
    <dd>Removes a registered observer in the connection.</dd>
  </dl>

  <p>Although observers are registered/unregistered via a database connection
  object, the changes they receive may come from other connections.
  The callback function is only a signal of query result change, and the users
  are responsible to re-execute observed query in a transaction if desired.
  Unlike trigger in relational databases, observers do not require
  implementations to execute the observed query.</p>

  <p class="note">
  The specification supports observations only for single select queries, not
  for <code>readonly</code> transactions.
  </p>
</section>


</section>

<section>
  <h2>Data Manipulation</h2>
  <p>Data manipulation of a database is carried out through transactions and
  the queries within. In this section, the APIs for constructing queries will
  be detailed.</p>

<section>
  <h2>Schema Representation</h2>
  <p>The fundamental part of data manipulation is to specify what to
  manipulate. In a relational database, this implies table and columns in the
  schema. The schema objects for data manipulation are acquired through
  <a>IDatabaseSchema</a> objects obtained from
  <a>ISchemaQueryProvider</a><code>.schema()</code> offered by
  <a>DatabaseConnection</a>. The schema table is modeled as following:</p>

  <pre class="idl">
    interface ITable {
      ITable as(DOMString alias);
    };
  </pre>
  <dl class="methods">
    <dt><code>ITable as(DOMString alias)</code><dt>
    <dd>Creates an alias for the table, this is useful for self-join.</dd>
  </dl>

  <p>The <a>ITable</a> objects MUST have attributes that are named as columns
  of that table, and the attributes are <a>IColumn</a> objects.</a>

  <pre class="idl">
    interface IColumn : IPredicate {
      readonly attribute DOMString name;
      readonly attribute ColumnType type;
      readonly attribute boolean nullable;
      IColumn as(DOMString alias);
    };
  </pre>
  <dl class="attributes">
    <dt><code>name</code></dt>
    <dd>The <a>canonical name</a> of the column.</dd>
    <dt><code>type</code></dt>
    <dd>Data type of the column.</dd>
    <dt><code>nullable</code></dt>
    <dd>When <code>false</code>, the column is <a>NOT NULL</a></dd>
  </dl>
  <dl class="methods">
    <dt><code>IColumn as(DOMString alias);</code></dt>
    <dd>Creates an alias for the column. The alias will be honored in select
    queries only.</dd>
  </dl>
</section>

<section>
  <h2>Common Query Behaviors</h2>
  <p>Data manipulation queries are created from the <a>IDataQueryProvider</a>
  interface, which is implemented by the <a>DatabaseConnection</a> object.</p>

  <pre class="idl">
    interface IDataQueryProvider {
      ISelectQuery select(IColumn... columns);
      IInsertQuery insert();
      IInsertQuery insertOrReplace();
      IUpdateQuery update(ITable table);
      IDeleteQuery delete();
    };
  </pre>
  <dl class="methods">
    <dt><code>ISelectQuery select(IColumn... columns);</code></dt>
    <dd>Creates a <a href="#select-query">select query</a> to retrieve data
    from database.</dd>
    <dt><code>IInsertQuery insert();</code></dt>
    <dd>Creates an <a href="#insert-query">insert query</a> to insert data into
    database.</dd>
    <dt><code>IInsertQuery insertOrReplace();</code></dt>
    <dd>Similar to <a href="#insert-query">insert query</a>, but behaves
    differently for primary key conflicts.</dd>
    <dt><code>IUpdateQuery update(ITable table);</code></dt>
    <dd>Creates an <a href="#update-query">update query</a> to update existing
    data in the database.</dd>
    <dt><code>IDeleteQuery delete();</code></dt>
    <dd>Creates a <a href="#delete-query">delete query</a> to remove data from
    database.</dd>
  </dl>

  <p>All queries MUST inherit from this base query interface.</p>
  <pre class="idl">
    interface IQuery : IExecutionContext {
      Promise< DOMString > explain();
      IQuery bind(any... values);
      DOMString toSql();
    };
  </pre>
  <dl class="methods">
    <dt><code>Promise< DOMString > explain();</code></dt>
    <dd>Explains how this query will be executed in transaction. The returned
    string representation will be implementation-dependent. The specification
    recommends implementations to return the query execution plan and other
    useful information for developers to do performance tuning of their
    queries.</dd>
    <dt><code>IQuery bind(any... values);</code></dt>
    <dd>Creates a clone of this query, assigns values to <a>IBindableValue</a>
    inside the cloned query, and returns the cloned query for execution.</a>
    <dt><code>DOMString toSql();</code></dt>
    <dd>Converts the query to equivalent SQL statements. The returned SQL
    string will also be implementation-dependent, or <code>null</code> if the
    implementation does not support this feature. The specification recommends
    SQL-03 standard for generating SQL statements.</dd>
  </dl>
</section>

<section>
  <h2>Insert Query</h2>
  <p>Insert queries are used to insert rows into tables. There are two
  variations of insert queries: <code>insert</code> and
  <code>insertOrReplace</code>. Both variations support the following
  interface:</p>

  <pre class="idl">
    interface IInsertQuery : IQuery {
      IInsertQuery into(ITable table);
      IInsertQuery values((object or object[] or IBindableValue or IBindableValue[]) rows);
    };
  </pre>
  <dl class="methods">
    <dt><code>IInsertQuery into(ITable table);</code></dt>
    <dd>Specifies the target table to insert rows into. For
    <code>insertOrReplace</code>, the <code>table</code> MUST have a primary
    key, otherwise <a>IntegrityError</a> will be thrown.</dd>
    <dt><code>IInsertQuery values((object or object[] or IBindableValue or IBindableValue[]) rows);</code></dt>
    <dd>Supplies the row(s) to be inserted. When given an <code>object</code>
    as parameter, or the bindable value resolved as an object, the object will
    act as a single row; otherwise, each element in the given array is treated
    as an individual row.</dd>
  </dl>
  <p>All methods of <a>IInsertQuery</a> returns the calling
  <code>IInsertQuery</code> object for cascade builder pattern. The methods can
  only be called once per query, otherwise <a>SyntaxError</a> MUST be raised.
  </p>

  <p>If an <a>IInsertQuery</a> object is created from <code>insert</code>,
  and a row with duplicated primary key is given, <a>ConstraintError</a>
  MUST be thrown if query engine detected integrity violation. On the other
  hand, if the <a>IInsertQuery</a> object is from <code>insertOrReplace</code>,
  the offended row MUST be silently replaced by the new row provided,
  effectively as removing the offended row and insert the offending row.</p>

  <p>If any of the inserted row causes integrity violation other than primary
  key, a <a>ConstraintError</a> MUST be thrown regardless.</p>

  <p>If any of the given rows does not exactly match the table schema of the
  table specified, <a>DataError</a> MUST be raised. Exact match means that each
  column specified in the table schema MUST appear as a property of any
  object provided as row.</a>

  <p class="note"><a>IBindableValue</a> can also resolve as an array of
  objects to provide multiple rows in one call.</p>
</section>

<section>
  <h2>Delete Query</h2>
  <p>Delete queries are used to delete rows in a table. The rows to be deleted
  are specified via <a href="#search-condition">Search Condition</a>. The delete
  query implements the following interface:</p>

  <pre class="idl">
    interface IDeleteQuery : IQuery {
      IDeleteQuery from(ITable table);
      IDeleteQuery where(IPredicate searchCondition);
    };
  </pre>
  <dl class="methods">
    <dt><code>IDeleteQuery from(ITable table);</code></dt>
    <dd>Specifies the target table to delete rows from.</dd>
    <dt><code>IDeleteQuery where(IPredicate searchCondition);</code></dt>
    <dd>Specifies the search condition for filtering rows.</dd>
  </dl>
  <p>All methods of <a>IDeleteQuery</a> returns the calling
  <code>IDeleteQuery</code> object for cascade builder pattern. The methods can
  only be called once per query, otherwise <a>SyntaxError</a> MUST be raised.
  </p>

  <p>If the table is empty, or the search condition returns no matching rows,
  the delete query will finish successfully without doing anything. If deleting
  rows cause data integrity violation (for example, deleting a row that is
  referred in a foreign key), a <a>ConstraintError</a> MUST be raised.</p>
</section>

<section>
  <h2>Data Query</h2>
  <pre class="idl">
    interface ISelectQuery : IQuery {
      ISelectQuery from(ITable... tables);
      ISelectQuery where(IPredicate searchCondition);
      ISelectQuery innerJoin(ITable table, Predicate onCondition);
      ISelectQuery leftOuterJoin(ITable table, Predicate onCondition);
      ISelectQuery limit((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery skip((unsigned long or IBindableValue) numberOfRows);
      ISelectQuery orderBy(IColumn column, optional Order order);
      ISelectQuery groupBy(IColumn... column);
    };
  </pre>
  <pre class="idl">
    interface IUpdateQuery : IQuery {
      IUpdateQuery set(IColumn column, ValueType value);
      IUpdateQuery where(IPredicate searchCondition);
    };
  </pre>
  <pre class="idl">
    typedef (boolean or Date or number or DOMString) IndexableValueType;
    typedef (IndexableValueType or IBindableValue) ComparableValueType;

    interface IPredicate {
      IPredicate eq(ComparableValueType value);
      IPredicate neq(ComparableValueType value);
      IPredicate lt(ComparableValueType value);
      IPredicate lte(ComparableValueType value);
      IPredicate gt(ComparableValueType value);
      IPredicate gte(ComparableValueType value);
      IPredicate match((IBindableValue or RegExp) value);
      IPredicate between(ComparableValueType value, ComparableValueType value);
      IPredicate in((ComparableValueType[] or IBindableValue) values);
      IPredicate isNull();
      IPredicate isNotNull();

      IPredicate not(IPredicate childPredicate);
      IPredicate and(IPredicate... childPredicate);
      IPredicate or(IPredicate... childPredicate);
    };
  </pre>
  <section>
    <h2>Aggregation Functions</h2>
    <pre class="idl">
      interface IAggregateFunction {
        IColumn avg(IColumn col);
        IColumn count(optional IColumn col = null);
        IColumn geomean(IColumn col);
        IColumn max(IColumn col);
        IColumn min(IColumn col);
        IColumn stddev(IColumn col);
        IColumn sum(IColumn col);
        IColumn var(IColumn col);
      };
    </pre>
  </section>
  <pre class="idl">
    interface IDatabaseFunctionProvider : IAggregateFunction {
      IColumn distinct(IColumn... col);
    };
  </pre>
</section>

<section>
  <h2>Bindable Values</h2>
  <pre class="idl">
    interface IBindableValue {
      readonly attribute any value;
    };
  </pre>
  <p>Type check of bound value is performed by query engine before executing
  the query.</p>

  <p>The following example demonstrate how to perform parameterized query using
  data binding:</p>
  <pre class="example highlight">
var db;

var query;

function init() {
  var dept = db.schema().table('Department');

  var emp = db.schema().table('Employee');
  query = db.select(emp.name.as('ename'), dept.name)
            .from(dept, emp)
            .where(dept.id.eq(emp.deptId).and(
                   emp.id.eq(db.bind(0))));
}

function updateModel(employeeId) {
  query.bind(employeeId).commit().then(function(rows) {
    console.log(rows[0]['ename'], rows[0]['Department.name']);
  });
}

  </pre>
</section>


</section>

<section>
  <h2>Errors</h2>
  <p>All errors in this specification are <code>DOMException</code> with the
  specified error type.</p>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td><dfn><code>BlockingError</code></dfn></td>
      <td>Attempts to open a delete pending database, or to create a
      transaction in a close pending connection.</td></tr>
    <tr><td><dfn><code>ConstraintError</code></dfn></td>
        <td>Constraints are violated.</td>
    </tr>
    <tr><td><dfn><code>DataError</code></dfn></td>
        <td>Data given to a column is invalid. For example, assigning <code>
            null</code> or <code>undefined</code> to a <a>NOT NULL</a> column,
            or assigning values of different <a href="#column-type">column type
            </a>.</td>
    </tr>
    <tr><td><dfn><code>IntegrityError</code></dfn></td>
        <td>Query engine is not able to ensure data integrity. For example,
        failed to rollback a sequence mode transaction.</td></tr>
    <tr><td><dfn><code>InvalidSchemaError</code></dfn></td>
        <td>Provided schema is invalid.</td>
    </tr>
    <tr><td><dfn><code>SyntaxError</code></dfn></td>
      <td>Illegal use of query builder objects, for example, calling
      <code>into()</code> twice for <a>IInsertQuery</a>.</td>
    <tr><td><dfn><code>TransactionStateError</code></dfn></td>
      <td>Attempts to commit/rollback/attach query to a finished/pending finish
      transaction.</td></tr>
    <tr><td><dfn><code>UnsupportedError</code></dfn></td>
      <td>Attempts to use MAY support features that are not supported yet.
      </td></tr>
  </table>
</section>

 </body>
</html>
