<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>Relational Database API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'ED',
        shortName: 'rdb',
        editors: [
          {
            name: 'Arthur Hsu',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          },
          {
            name: 'Demetrios Papadopoulos',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          }
        ],
        wg: 'Relational Database API Interest Group',
        wgURI: 'https://www.github.com/arthurhsu/rdb',
        edDraftURI: 'https://www.github.com/arthurhsu/rdb'
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
      This document defines APIs for a database of tables holding rows, each row
      represents a tuple of data fields. The type of data fields must be
      predefined. These APIs provide query capabilities that are comparable to a
      subset of SQL-03 standard.
      </p>
    </section>

    <section id="sotd">
      <p>This document has not been submitted to anywhere yet.</p>
    </section>

<section class="informative">
  <h2>Introduction</h2>
  <p>Relational data manipulation for the web apps has been in a difficult
  state for years. WebSQL has quite a few problems with itself and hence
  deprecated. The poised substitute, IndexedDB, is actually an object database.
  In this document, an easy-to-use APIs are defined to promote readable,
  maintainable, and performance code for apps needing relational data.</p>
  
  <p>Why a new standard is proposed instead of modifying existing IndexedDB?
  There are some very good reasons of doing so.</p>
  <ul>
    <li>Making IndexedDB more bloated with the features that object databases
    don't need simply makes no sense.</li>

    <li>At the time of drafting this spec, most browsers carry a C++ relational
    database implementation without exposing it.</li>

    <li>Fundamentally the algorithms behind an object database and a relational
    database are different. Shoehorning a relational query layer on top of
    IndexedDB creates unnecessary complexity. Users are either forced to write
    their own domain-specific query engine, or to include a large JS library
    (e.g. Lovefield).</li>

    <li>IndexedDB assumes single-level B-Tree index and object store structure
    are good enough, which is not true for relational data manipulation.</li>

    <li>JavaScript lacks many fundamental support needed by relational query
    engine, especially for memory management and storage management.</li>
  </ul>

  <p>The APIs proposed in this document are designed for small-scale relational
  data manipulation. The following example shows how to open a database.</p>
  <pre class="example highlight">
// Open database named 'hr'.
// If the named instance does not exist, create an empty database instance.
// Otherwise, open the existing database named 'hr'.
var db;

function openDatabase() {
  return navigator.db.open('hr').then(function(instance) {
    db = instance;

    // version is a read-only number that is for reference only.
    if (db.version == 0) {
      // This is an empty database.
      return setUpNewDb();
    } else if (db.version < 2) {
      // Version is smaller than expected, perform upgrades.
      return upgradeDb();
    }
  });
}

function setUpNewDb() {
  var tx = db.createTransaction('readwrite');
  var q1 = db.createTable('Dept')
             .column(/* column_name */ 'id',
                     /* column_type */ 'String',
                     /* not_null */ true)
             .column('name', 'String', true)
             .column('desc', 'String')
             .primaryKey([{'name': 'id'}]);

  var q2 = db.createTable('Emp')
             .column('id', 'Number', true)
             .column('name', 'String', true)
             .column('deptId', 'String', true)
             .column('title', 'String')
             .primaryKey([{name: 'id', order: 'asc'}])
             .unique(['name'])
             .index('idx_Desc', [{name: 'desc', order: 'asc'}])
             .foreignKey({
               'name': 'fk_DeptId',
               'local': 'deptId',
               'remote': 'Dept.id',
               'action': 'restrict',
               'timing': 'immediate'
             });
  var q3 = db.setVersion(2);

  tx.append([q1, q2, q3]);
  return tx.commit();
}

function upgradeDb() {
  return db.alterTable('Dept').addColumn('desc', 'String').commit();
}

openDatabase().then(function() {
  // Real work starts here.
});

  </pre>
  <p>Once the database is opened, queries can be performed.</p>
  <pre class="example highlight">
var d = db.table('Dept');

function insertData() {
  var deptData = [
    {'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
    {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
    {'id': 'NADA', 'name': 'Non existing'},
    {'id': 'L', 'name': 'Leadership'}
  ];
  return db.insert().into(d).values(deptData).commit();
}

function updateData() {
  return db.update(d).set(d.desc, 'Master minds').where(d.id.eq('L')).commit();
}

function deleteData() {
  return db.delete().from(d).where(d.id.eq('NADA')).commit();
}

function selectData() {
  return db.select().from(d).commit();
}

insertData().then(function() {
  return updateData();
}).then(function() {
  return deleteData() {
}).then(function() {
  return selectData() {
}).then(function(rows) {
  // Expected returns:
  // [{'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
  //  {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
  //  {'id': 'L', 'name': 'Leadership', 'desc': 'Master minds'}]
  console.log(rows);
});

  </pre>
</section>

    <section id="conformance"></section>

<section>
  <h2>Constructs</h2>
<section>
  <h2>Database</h2>
  <p>A database's origin is the same as the origin of the document or worker.
  Each origin has an associated set of database.</p>

  <p class="note">The database origin is not affected by changes to
  <code>document.domain</code>.</p>

  <p>Each origin has an associated set of databases. A database comprises one
  or more tables which hold the data stored in the database.</p>

  <p>Every database has a <em>name</em> which identifies it within a specific
  origin. The name can be any string value, except empty string, and stays
  constant for the lifetime of the database.</p>

  <p>Each database also has a version number for reference only. When a
  database is first created, its version is 0.</p>

  <p class="note">Implementations must support all names. If an implementation
  uses a storage mechanism which can't handle arbitrary database names, the
  implementation must use an escaping mechanism or something similar to map
  the provided name to a name that it can handle.</p>

  <p>Databases has a <em>delete pending</em> flag which is used during
  deletion. When a database is requested to be deleted the flag is set to true
  and all attempts at opening the database are stalled until database is
  deleted.</p>

  <p>The act of opening a database creates a <em>connection</em>. There may be
  multiple connections to a given database at any given time. Each connection
  has a <em>closePending</em> flag which initially is set to false.</p>

  <p>When a connection is initially created it is in opened state. The
  connection can be closed through several means. If the connection is garbage
  collected or execution context where the connection is created is destroyed
  (for example due to the user navigating away from that page), the connection
  is closed. The connection can also be closed explicitly using the steps for
  closing a database connection. When the connection is closed the
  closePending flag is always set to true if it hasn't already been. All
  uncommitted transactions will be cancelled if their associated connections
  are marked close pending.</p>

  <p>Every database contains a <em>schema</em> that defines data types,
  referential integrity enforcement, and indices for the stored data.</p>

  <p>Users can create observers associated with a given database. Each
  observer consists a select query. When the results of that select query
  change, the observer will be triggered.</p>

  <p>The <code>IDatabaseConnection</code> interface represents a connection to
  a database.</p>
</section>

<section>
  <h2>Schema</h2>
  <p>The concept of relational database is to have a predefined layout of the
  data structures persisted, which is referred as schema throughout this
  document. A database schema consists of a list of table schemas. Each table
  schema has a list of column definitions, constraints, and index
  specifications for that table.</p>

<section>
  <h2>Types</h2>
  <p>All columns must be associated with a given type. Valid types of a column
  are defined in the following enum:</p>
  <dl title='enum ColumnType' class='idl'>
    <dt>ArrayBuffer</dt>
    <dd>Represents the <code>ArrayBuffer</code> type in JavaScript</dd>
    <dt>Boolean</dt>
    <dd>Represents the <code>boolean</code> type in JavaScript</dd>
    <dt>Date</dt>
    <dd>Represents the <code>Date</code> type in JavaScript</dd>
    <dt>Number</dt>
    <dd>Represents the <code>Number</code> type in JavaScript</dd>
    <dt>String</dt>
    <dd>Represents the <code>string</code> type in JavaScript</dd>
    <dt>Object</dt>
    <dd>Represents the <code>Object</code> type in JavaScript</dd>
  </dl>
  <p><code>ArrayBuffer</code> and <code>Object</code> type are not
  <em>indexable</em>, which means columns of these types could not be used to
  create indices and predicates (except the <code>isNull()</code> and
  <code>isNotNull()</code> predicates).</p>
</section>


  <p>The following example demonstrates how to create a database schema.</p>
  <pre class="example highlight">
// Create a database using predefined JSON schema.
var hrSchema = {
  'name': 'hr',
  'version': 2,
  'table': [
    {
      'name': 'Dept',
      'column': [
        {'name': 'id', 'type': 'String'},
        {'name': 'name', 'type': 'String'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id'}],
        'notNull': ['name']
      }
    },
    {
      'name': 'Emp',
      'column': [
        {'name': 'id', 'type': 'Number'},
        {'name': 'name', 'type': 'String'},
        {'name': 'deptId', 'type': 'String'},
        {'name': 'title', 'type': 'String'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id', 'order': 'desc'}],
        'foreignKey': [{
          'name': 'fk_DeptId',
          'local': 'deptId',
          'remote': 'Dept.id',
          'action': 'restrict',
          'timing': 'immediate'
        }],
        'unique': ['name'],
        'notNull': ['id', 'name', 'deptId']
      }
    }
  ]
};

db.create(hrSchema).commit().then(function(instance) {
  // Instance is the connected instance.
}, function(e) {
  // e is the DOMError if any, e.g. AlreadyExists.
});

  </pre>
  <pre class="example highlight">
var tx = db.createTransaction('readwrite');
var q1 = db.createTable('Dept')
           .column(/* column_name */ 'id',
                   /* column_type */ 'String',
                   /* not_null */ true)
           .column('name', 'String', true)
           .primaryKey([{'name': 'id'}]);
tx.append(q1);

var q2 = db.createTable('Emp')
           .column('id', 'Number', true)
           .column('name', 'String', true)
           .column('deptId', 'String', true)
           .column('title', 'String')
           .primaryKey([{'name': 'id', 'order': 'asc'}])
           .unique(['name'])
           .index('idx_Desc', [{'name': 'desc', 'order': 'asc'}])
           .foreignKey({
             'name': 'fk_DeptId',
             'local': 'deptId',
             'remote': 'Dept.id',
             'action': 'restrict',
             'timing': 'immediate'
           });
q2.attachTo(tx);

tx.commit().then(...);

  </pre>
</section>

</section>


 </body>
</html>
