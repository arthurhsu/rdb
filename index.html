<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>Relational Database API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'ED',
        shortName: 'rdb',
        editors: [
          {
            name: 'Arthur Hsu',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          },
          {
            name: 'Demetrios Papadopoulos',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          }
        ],
        wg: 'Relational Database API Interest Group',
        wgURI: 'https://www.github.com/arthurhsu/rdb',
        edDraftURI: 'https://www.github.com/arthurhsu/rdb'
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
      This document defines APIs for a database of tables holding rows, each row
      represents a tuple of data fields. The type of data fields must be
      predefined. These APIs provide query capabilities that are comparable to a
      subset of SQL-03 standard.
      </p>
    </section>

    <section id="sotd">
      <p>This document has not been submitted to anywhere yet.</p>
    </section>

<section class="informative">
  <h2>Introduction</h2>
  <p>Relational data manipulation for the web apps has been in a difficult
  state for years. WebSQL has quite a few problems with itself and hence
  deprecated. The poised substitute, IndexedDB, is actually an object database.
  In this document, an easy-to-use APIs are defined to promote readable,
  maintainable, and performance code for apps needing relational data.</p>

  <p>Why a new standard is proposed instead of modifying existing IndexedDB?
  There are some very good reasons of doing so.</p>
  <ul>
    <li>Making IndexedDB more bloated with the features that object databases
    don't need simply makes no sense.</li>

    <li>At the time of drafting this spec, most browsers carry a C++ relational
    database implementation without exposing it.</li>

    <li>The algorithms behind an object database and a relational database are
    different. Shoehorning a relational query layer on top of IndexedDB creates
    unnecessary complexity. Users are either forced to write their own
    domain-specific query engine, or to include a third party JS library (e.g.
    Lovefield).</li>

    <li>IndexedDB assumes single-level B-Tree index and object store structure
    are good enough, which is not true for relational data manipulation.</li>

    <li>JavaScript lacks many fundamental support needed by relational query
    engine, especially for memory management and storage management.</li>
  </ul>

  <p>The APIs proposed in this document are designed for small-scale relational
  data manipulation. The following example shows how to open a database.</p>
  <pre class="example highlight">
// Open database named 'hr'.
// If the named instance does not exist, create an empty database instance.
// Otherwise, open the existing database named 'hr'.
var db;

function openDatabase() {
  return navigator.db.open('hr').then(function(instance) {
    db = instance;

    // version is a read-only number that is for reference only.
    if (db.version == 0) {
      // This is an empty database.
      return setUpNewDb();
    } else if (db.version < 2) {
      // Version is smaller than expected, perform upgrades.
      return upgradeDb();
    }
  });
}

function setUpNewDb() {
  var tx = db.createTransaction('readwrite');
  var q1 = db.createTable('Dept')
             .column(/* column_name */ 'id',
                     /* column_type */ 'String',
                     /* not_null */ true)
             .column('name', 'String', true)
             .column('desc', 'String')
             .primaryKey([{'name': 'id'}]);

  var q2 = db.createTable('Emp')
             .column('id', 'Number', true)
             .column('name', 'String', true)
             .column('deptId', 'String', true)
             .column('title', 'String')
             .primaryKey([{name: 'id', order: 'asc'}])
             .unique(['name'])
             .index('idx_Desc', [{name: 'desc', order: 'asc'}])
             .foreignKey({
               'name': 'fk_DeptId',
               'local': 'deptId',
               'remote': 'Dept.id',
               'action': 'restrict',
               'timing': 'immediate'
             });
  var q3 = db.setVersion(2);

  tx.append([q1, q2, q3]);
  return tx.commit();
}

function upgradeDb() {
  return db.alterTable('Dept').addColumn('desc', 'String').commit();
}

openDatabase().then(function() {
  // Real work starts here.
});

  </pre>
  <p>Once the database is opened, queries can be performed.</p>
  <pre class="example highlight">
var d = db.table('Dept');

function insertData() {
  var deptData = [
    {'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
    {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
    {'id': 'NADA', 'name': 'Non existing'},
    {'id': 'L', 'name': 'Leadership'}
  ];
  return db.insert().into(d).values(deptData).commit();
}

function updateData() {
  return db.update(d).set(d.desc, 'Master minds').where(d.id.eq('L')).commit();
}

function deleteData() {
  return db.delete().from(d).where(d.id.eq('NADA')).commit();
}

function selectData() {
  return db.select().from(d).commit();
}

insertData().then(function() {
  return updateData();
}).then(function() {
  return deleteData() {
}).then(function() {
  return selectData() {
}).then(function(rows) {
  // Expected returns:
  // [{'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
  //  {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
  //  {'id': 'L', 'name': 'Leadership', 'desc': 'Master minds'}]
  console.log(rows);
});

  </pre>
</section>

    <section id="conformance"></section>

<section>
  <h2>Constructs</h2>
<section>
  <h2>Database</h2>
  <p>A database's origin is the same as the origin of the document or worker.
  Each origin has an associated set of database.</p>

  <p class="note">The database origin is not affected by changes to
  <code>document.domain</code>.</p>

  <p>Each origin has an associated set of databases. A database comprises one
  or more tables which hold the data stored in the database.</p>

  <p>Every database has a <em>name</em> which identifies it within a specific
  origin. The name must satisfy the Naming Rules, and stay constant for the
  lifetime of the database.</p>

  <p>Each database also has a version number for reference only. When a
  database is first created, its version is 0.</p>

  <p class="note">Implementations must support all names. If an implementation
  uses a storage mechanism which can't handle arbitrary database names, the
  implementation must use an escaping mechanism or something similar to map
  the provided name to a name that it can handle.</p>

  <p>Databases has a <em>delete pending</em> flag which is used during
  deletion. When a database is requested to be deleted the flag is set to true
  and all attempts at opening the database are stalled until database is
  deleted.</p>

  <p>The act of opening a database creates a <em>connection</em>. There may be
  multiple connections to a given database at any given time. Each connection
  has a <em>closePending</em> flag which initially is set to false.</p>

  <p>When a connection is initially created it is in opened state. The
  connection can be closed through several means. If the connection is garbage
  collected or execution context where the connection is created is destroyed
  (for example due to the user navigating away from that page), the connection
  is closed. The connection can also be closed explicitly using the steps for
  closing a database connection. When the connection is closed the
  closePending flag is always set to true if it hasn't already been. All
  uncommitted transactions will be cancelled if their associated connections
  are marked close pending.</p>

  <p>Every database contains zero or more <em>tables</em> to store data. A
  table contains zero or more <em>rows</em>. A row is also known as a record or
  a tuple, which represents a single structured data item in a table. A row
  consists zero or more <em>columns</em>, each with predefined data types.
  A database can also contain <em>indices</em>. An index is a data structure
  that enables fast lookup and/or enforces data integrity.</p>

  <p>Every database has a predefined layout of the data structures persisted,
  which is referred as <em>schema</em> throughout this document. A database
  schema consists of a list of table schemas. Each table schema describes the
  structures of the rows stored within it, which is also referred as 
  <em>column definitions</em>. A table schema also describes
  <em>constraints</em> and <em>index</em> structures for that table.</p>

  <p>Users can create observers associated with a given database. Each
  observer consists a select query. When the results of that select query
  change, the observer will be triggered.</p>

  <p>The <code>IDatabaseConnection</code> interface represents a connection to
  a database.</p>
</section>

<section>
  <h2>Naming Rules</h2>
  <p>All names used in the relational database are case sensitive, and they
  must satisfy following rules:</p>
  <ul>
    <li>A name must pass the following check:
        <code>/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)</code>
    </li>
    <li>A name must not conflict with fields defined in
        <code>Object.prototype</code>
    </li>
  </ul>
</section>

<section>
  <h2>Transaction</h2>
  <p>A <em>transaction</em> is used to interact with data in a database. Data is
  read from or written to database via transaction.</p>

  <p>All transactions are associated with a database connection, which is the
  <em>connection</em> that the transaction is created within. A transaction has
  a predetermined <em>mode</em> to indicate what access this transaction is
  asking for. The mode is set when the transaction is created and remains fixed
  for the life of the transaction. There are two transaction modes:</p>

  <dl title="enum TransactionMode" class="idl">
    <dt>readonly</dt>
    <dd>Transaction intends to read rows only.</dd>
    <dt>readwrite</dt>
    <dd>Transaction intends to read/write rows and/or change schema.</dd>
  </dl>

  <p>A transaction contains one or more <em>queries</em> that indicate how to
  interact with the database. A transaction is an atomic unit of execution that
  guarantees all queries inside this transaction to be committed as a whole, or
  none get committed. A committed transaction guarantees all persistent data
  being written to the persistent storage.</p>

  <p>A transaction has a <em>scope</em> that determines the rows affected by
  this transaction. The scope is automatically calculated. A transaction's scope
  can dynamically change for the lifetime of the transaction.</p>

  <p>A transaction can be created explicitly or implicitly. An explicit
  transaction is created directly from connection's
  <code>createTransaction()</code> function. An implicit transaction is created
  from a query's <code>exec()</code> method.</p>

  <p>A transaction's lifetime is controlled by the user. For implicit
  transactions, <code>exec()</code> starts the execution of transaction, and
  returns a result <code>Promise</code>. The promise is resolved if and only if
  the transaction is committed, and is rejected if the transaction did not
  commit. For explicit transaction, there are two ways to start execution:
  <em>batch mode</em> and <em>sequence mode</em>. In batch mode, explicit
  transaction is started with <code>exec(queriesArray)</code> and returns
  a result <code>Promise</code>. All queries will be executed sequentially in
  the order received. In sequence mode, user calls <code>begin()</code> to
  start the transaction, calls <code>attach(query)</code> to attach a query to
  the transaction's execution context. The user can call <code>commit()</code>
  to indicate the end of transaction, and a result <code>Promise</code> will be
  returned; or the user can call <code>rollback()</code> to abort the
  transaction, and all modifications done by previous attached queries will be
  discarded.</p>

  <p>When a transaction is committed or rolled back, it is said to be
  <em>finished</em>. A finished transaction cannot be started nor rolled back.
  If a transaction's connection is lost before transaction being finished, the
  transaction is effectively aborted and no changes will be persisted.</p>

</section>

<section>
  <h2>Errors</h2>
  <p>All errors in this specification are <code>DOMException</code> with the
  specified error type.</p>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td><code>ConstraintError</code></td>
        <td>Constraints are violated.</td>
    </tr>
    <tr><td><code>InvalidSchemaError</code></td>
        <td>Provided schema is invalid.</td>
    </tr>
  </table>
</section>

</section>

<section>
  <h2>Relational Database API</h2>

<section>
  <h2>Schema</h2>
  <p>The database schema can be described in JSON format or via builder pattern
  APIs. Schema can be changed through schema queries within any
  <code>readwrite</code> transactions. The JSON format and related APIs are
  described in the following sections.</p>

<section>
  <h2>Types</h2>
  <p>All columns in a table schema must be associated with a given type. Valid
  types of a column are defined in the following enum:</p>
  <dl title="enum ColumnType" class="idl">
    <dt>ArrayBuffer</dt>
    <dd>Represents the <code>ArrayBuffer</code> type in JavaScript</dd>
    <dt>Boolean</dt>
    <dd>Represents the <code>boolean</code> type in JavaScript</dd>
    <dt>Date</dt>
    <dd>Represents the <code>Date</code> type in JavaScript</dd>
    <dt>Number</dt>
    <dd>Represents the <code>Number</code> type in JavaScript</dd>
    <dt>String</dt>
    <dd>Represents the <code>string</code> type in JavaScript</dd>
    <dt>Object</dt>
    <dd>Represents the <code>Object</code> type in JavaScript</dd>
  </dl>
  <p><code>ArrayBuffer</code> and <code>Object</code> types are not
  <em>indexable</em>, which means columns of these types could not be used to
  create indices and predicates (except the <code>isNull()</code> and
  <code>isNotNull()</code> predicates).</p>
</section>

<section>
  <h2>Orders</h2>
  <p>There are two sorting orders defined in the following enum:</p>
  <dl title="enum Order" class="idl">
    <dt>asc</dt>
    <dd>Represents ascending sort order (Default)</dd>
    <dt>desc</dt>
    <dd>Represents descending sort order</dd>
  </dl>
  <p>Ascending sort order is the natural sort order, which means that if two
  fields are ordered as <code>a, b</code>, then <code>(a <= b) === true</code>.
  <code>ArrayBuffer</code> and <code>Object</code> types are not
  <em>indexable</em>, which implied they were not <em>comparable</em> and thus
  the orders have no effect for these two types.</p>
</section>

<section>
  <h2>Schema Definition JSON Format</h2>
  <p>Database schema can be defined using a single dictionary object. The
  following example demonstrates how to create a database using such object.</p>
  <pre class="example highlight">
// Create a database using predefined JSON schema.
var hrSchema = {
  'name': 'hr',
  'version': 2,
  'table': [
    {
      'name': 'Dept',
      'column': [
        {'name': 'id', 'type': 'String'},
        {'name': 'name', 'type': 'String'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id'}],
        'notNull': ['name']
      }
    },
    {
      'name': 'Emp',
      'column': [
        {'name': 'id', 'type': 'Number'},
        {'name': 'name', 'type': 'String'},
        {'name': 'deptId', 'type': 'String'},
        {'name': 'title', 'type': 'String'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id', 'order': 'desc'}],
        'foreignKey': [{
          'name': 'fk_DeptId',
          'local': 'deptId',
          'remote': 'Dept.id',
          'action': 'restrict',
          'timing': 'immediate'
        }],
        'unique': [{
          'name': 'uq_Name',
          'column': [{'name': 'name', 'order': 'desc'}]
        }],
        'notNull': ['id', 'name', 'deptId']
      },
      'index': [
        {
          'name': 'idx_Title',
          'column': [{'name': 'title', 'order': 'asc'}]
        }
      ]
    }
  ]
};

db.create(hrSchema).commit().then(function(instance) {
  // Instance is the connected instance.
}, function(e) {
  // e is the DOMError if any, e.g. AlreadyExists.
});

  </pre>

  <p>The following WebIDL defines <code>Schema</code> dictionary type.
  <pre class="idl">
    dictionary Schema {
      DOMString name;
      unsigned short version;
      TableSpec[] table;
    };
  </pre>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td>name</td><td>Name of the database</td></tr>
    <tr><td>version</td>
      <td>(Optional) Version of the database, for reference only</td>
    </tr>
    <tr><td>table</td><td>Array of table specifications</td></tr>
  </table>

  <section>
    <h2>Table Specifications</h2>
    <p>The following WebIDL defines table specification dictionary type.</p>
    <pre class="idl">
      dictionary TableSpec {
        DOMString name;
        ColumnSpec[] column;
        ConstraintSpec? constraint;
        IndexSpec[]? index;
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the table</td></tr>
      <tr><td>column</td><td>Array of column definitions</td></tr>
      <tr><td>constraint</td><td>(Optional) Constraint definitions</td></tr>
      <tr><td>index</td><td>(Optional) Array of index definitions</td></tr>
    </table>

    <p>The following WebIDL defines column definition dictionary type:</p>
    <pre class="idl">
      dictionary ColumnSpec {
        DOMString name;
        ColumnType type;
        boolean? notNull;
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the column</td></tr>
      <tr><td>type</td><td>Type of the column</td></tr>
      <tr><td>notNull</td><td>(Optional) Not null</td></tr>
    </table>
  </section>

  <section>
    <h2>Index Definition</h2>
    <p>The following WebIDL defines index specification dictionary type:</p>
    <pre class="idl">
      dictionary IndexSpec {
        DOMString name;
        (DOMString or DOMString[] or IndexedColumnSpec[]) column;
        IndexType type = "btree";
        boolean unique = false;
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the index</td></tr>
      <tr><td>column</td><td>Indexed column definitions. If provided as
          <code>DOMString</code> or <code>DOMString[]</code>, default sort order
          of <code>asc</code> is used.</td></tr>
      <tr><td>type</td>
          <td>(Optional) Type of index, default to <code>btree</code></td></tr>
      <tr><td>unique</td><td>(Optional) Keys in index shall be unique or not,
          default to <code>false</code>.</td></tr>
    </table>
    <p>Index type allows user to hint the implementation what this index is
    best to be used for. The implementation may or may not construct the index
    using corresponding algorithm. The index type is an enum:</p>
    <dl title="enum IndexType" class="idl">
      <dt>btree</dt><dd>B+ Tree index</dd>
      <dt>hash</dt><dd>Hash index</dd>
    </dl>

    <p>An index can be keyed by one or more columns unless the
    <code>unique</code> is set to true. In that case, an
    <code>ConstraintError</code> will be thrown if user tried to insert/update
    a row with duplicated key.</p>

    <p>The WebIDL below defines indexed column specification.</p>
    <pre class="idl">
      dictionary IndexedColumnSpec {
        DOMString name;
        Order order = "asc";
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the indexed column</td></tr>
      <tr><td>order</td><td>(Optional) Sorting order of the column, default to
          <code>asc</code></td></tr>
    </table>
    <p>The name specified in the indexed column must exist in the same table
    defining this index, otherwise an <code>InvalidSchemaError</code> will be
    thrown. If the specified column is not indexable, an
    <code>InvalidSchemaError</code> will be thrown.</p>
    <p>If an index definition overlapped with implicit indices created by
    constraints (for example, create an index on the same column of the primary
    key), it will be up to the implementation to determine whether or not to
    create this index.</p>
  </section>

  <section>
    <h2>Constraint Specification</h2>
    <p>The following WebIDL defines constraint specification.</p>
    <pre class="idl">
      dictionary ConstraintSpec {
        (DOMString or DOMString[] or IndexedColumnSpec[] or PrimaryKeySpec)? primaryKey;
        ForeignKeySpec? foreignKey;
        (DOMString or DOMString[] or IndexedColumnSpec[])? unique;
        (DOMString or DOMString[])? notNull;
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>primaryKey</td><td>(Optional) Primary key specification</td></tr>
      <tr><td>foreignKey</td><td>(Optional) Foreign key definition</td></tr>
      <tr><td>unique</td><td>(Optional) Unique index definitions</td></tr>
      <tr><td>notNull</td><td>(Optional) Column(s) that are not null</td></tr>
    </table>
    <p>The name(s) specified in the notNull must exist in the same table
    defining this constraint, otherwise an <code>InvalidSchemaError</code>
    will be thrown. By default all columns accept null as valid value, unless
    the column is constrainted with notNull.</p>
  </section>

  <section>
    <h2>Unique Index Definition</h2>
    <p>Unique index is a specialized index that disallows duplicated keys.
    Its definition format is the same as index definition. If two or more
    columns are defined as keys, the combination of the columns forms the
    uniqueness.</p>
  </section>

  <section>
    <h2>Primary Key Specification</h2>
    <p>Each table can only have one primary key definition. The primary key
    will implicitly create an unique constraint and enforce it. A primary key
    can be specified using normal index specifications, or use the following
    WebIDL.</p>
    <pre class="idl">
      dictionary PrimaryKeySpec {
        DOMString name;
        boolean autoIncrement;
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Column name of the primary key</td></tr>
      <tr><td>autoIncrement</td><td>Create auto-increment key</td>
      </tr>
    </table>
    <p>When the autoIncrement field is specified, the specified column must be
    of type <code>Number</code>, otherwise an <code>InvalidSchemaError</code>
    will be thrown. An auto-increment key will start from zero. When a new row
    is inserted into the table, the key will increase by one and assigned to
    that row regardless the original key value given to the row.</p>
  </section>

  <section>
    <h2>Foreign Key Specification</h2>
    <p>The following WebIDL defines foreign key specification.</p>
    <pre class="idl">
      dictionary ForeignKeySpec {
        DOMString name;
        DOMString local;
        DOMString remote;
        ForeignKeyAction action = "restrict";
        ForeignKeyTiming timing = "immediate";
      };
    </pre>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the foreign key</td></tr>
      <tr><td>local</td><td>Referring column name</td></tr>
      <tr><td>remote</td><td>Referred column canonical name</td></tr>
      <tr>
        <td>action</td>
        <td>(Optional) Foreign key action, default: <code>restrict</code></td>
      </tr>
      <tr>
        <td>timing</td>
        <td>(Optional) Foreign key timing, default: <code>immediate</code></td>
      </tr>
    </table>
    <p>Foreign key actions are enum values as defined in the following:</p>
    <dl title="enum ForeignKeyAction" class="idl">
      <dt>restrict</dt>
      <dd>Any constraint violation results in cancelling the operation that
      violated the constraint.</dd>
      <dt>cascade</dt>
      <dd>Constraint violation results in modifying related tables as necessary
      to maintain data integrity.</dd>
    </dl>
    <p>Foreign key timings are enum values as defined below:</p>
    <dl title="enum ForeignKeyTiming" class="idl">
      <dt>deferrable</dt>
      <dd>The constraint is enforced right before a transaction is committed.
      The constraint can be violated by individual queries during the lifetime
      of the enclosing transaction, without any error being thrown.</dd>
      <dt>immediate</dt>
      <dd>The constraint is enforced during execution of each individual query.
      </dd>
    </dl>
  </section>

</section>

<section>
  <h2>Schema Query</h2>
  <p>Schema is created using schema queries. Schema queries can be used to
  create or modify database schema. Schema queries are run in the context of
  <em>transaction</em> and can be executed any time during the life time of the
  database. The schema query starts with the <code>ISchemaQueryProvider</code>:
  </p>
  <pre class="idl">
    interface ISchemaQueryProvider {
      IExecutionContext exportSchema();
      IExecutionContext create(Object schema);
      IDatabaseSchema schema();
      ITableBuilder createTable();
      ITableChanger alterTable();
    };
  </pre>
  <dl class="idl">
    <dt><code>IExecutionContext exportSchema();</code></dt>
    <dd>Export schema object. This is run in the context of transaction.</dd>
    <dt><code>IExecutionContext create(Object schema);</code></dt>
    <dd>Create database schema from provided schema object. The schema object
    must conform to the format defined in Schema Definition JSON Format.
    Any error in the schema will result in transaction failure with
    <code>InvalidSchemaError</code>.</dd>
    <dt><code>IDatabaseSchema schema();</code></dt>
    <dd>Returns an <code>IDatabaseSchema</code> object for crafting data
    manipulation queries.</dd>
    <dt><code>ITableBuilder createTable();</code></dt>
    <dd>Returns a table builder for creating a new table.</dd>
    <dt><code>ITableChanger alterTable(string tableName);</code></dt>
    <dd>Returns a table builder for altering an existing table.</dd>
  </dl>

  <p>The following example demonstrates how to create a database schema.</p>
    <pre class="example highlight">
var tx = db.createTransaction('readwrite');
var q1 = db.createTable('Dept')
           .column(/* column_name */ 'id',
                   /* column_type */ 'String',
                   /* not_null */ true)
           .column('name', 'String', true)
           .primaryKey([{'name': 'id'}]);
tx.append(q1);

var q2 = db.createTable('Emp')
           .column('id', 'Number', true)
           .column('name', 'String', true)
           .column('deptId', 'String', true)
           .column('title', 'String')
           .primaryKey([{'name': 'id', 'order': 'asc'}])
           .unique(['name'])
           .index('idx_Desc', [{'name': 'desc', 'order': 'asc'}])
           .foreignKey({
             'name': 'fk_DeptId',
             'local': 'deptId',
             'remote': 'Dept.id',
             'action': 'restrict',
             'timing': 'immediate'
           });
q2.attachTo(tx);

tx.commit().then(...);

  </pre>
</section>


</section>

</section>


 </body>
</html>
