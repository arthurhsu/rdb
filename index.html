<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>Relational Database API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'ED',
        shortName: 'rdb',
        editors: [
          {
            name: 'Arthur Hsu',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          },
          {
            name: 'Demetrios Papadopoulos',
            company: 'Google, Inc.',
            url: 'https://www.google.com'
          }
        ],
        wg: 'Relational Database API Interest Group',
        wgURI: 'https://www.github.com/arthurhsu/rdb',
        edDraftURI: 'https://www.github.com/arthurhsu/rdb'
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
      This document defines APIs for a database of tables holding rows, each row
      represents a tuple of data fields. The type of data fields must be
      predefined. These APIs provide query capabilities that are comparable to a
      subset of SQL-03 standard.
      </p>
    </section>

    <section id="sotd">
      <p>This document has not been submitted to anywhere yet.</p>
    </section>

<section class="informative">
  <h2>Introduction</h2>
  <p>Relational data manipulation for the web apps has been in a difficult
  state for years. WebSQL has quite a few problems with itself and hence
  deprecated. The poised substitute, IndexedDB, is actually an object database.
  In this document, an easy-to-use APIs are defined to promote readable,
  maintainable, and performance code for apps needing relational data.</p>
  
  <p>Why a new standard is proposed instead of modifying existing IndexedDB?
  There are some very good reasons of doing so.</p>
  <ul>
    <li>Making IndexedDB more bloated with the features that object databases
    don't need simply makes no sense.</li>

    <li>At the time of drafting this spec, most browsers carry a C++ relational
    database implementation without exposing it.</li>

    <li>Fundamentally the algorithms behind an object database and a relational
    database are different. Shoehorning a relational query layer on top of
    IndexedDB creates unnecessary complexity. Users are either forced to write
    their own domain-specific query engine, or to include a large JS library
    (e.g. Lovefield).</li>

    <li>IndexedDB assumes single-level B-Tree index and object store structure
    are good enough, which is not true for relational data manipulation.</li>

    <li>JavaScript lacks many fundamental support needed by relational query
    engine, especially for memory management and storage management.</li>
  </ul>

  <p>The APIs proposed in this document are designed for small-scale relational
  data manipulation. The following example shows how to open a database.</p>
  <pre class="example highlight">
// Open database named 'hr'.
// If the named instance does not exist, create an empty database instance.
// Otherwise, open the existing database named 'hr'.
var db;

function openDatabase() {
  return navigator.db.open('hr').then(function(instance) {
    db = instance;

    // version is a read-only number that is for reference only.
    if (db.version == 0) {
      // This is an empty database.
      return setUpNewDb();
    } else if (db.version < 2) {
      // Version is smaller than expected, perform upgrades.
      return upgradeDb();
    }
  });
}

function setUpNewDb() {
  var tx = db.createTransaction('readwrite');
  var q1 = db.createTable('Dept')
             .column(/* column_name */ 'id',
                     /* column_type */ 'String',
                     /* not_null */ true)
             .column('name', 'String', true)
             .column('desc', 'String')
             .primaryKey([{'name': 'id'}]);

  var q2 = db.createTable('Emp')
             .column('id', 'Number', true)
             .column('name', 'String', true)
             .column('deptId', 'String', true)
             .column('title', 'String')
             .primaryKey([{name: 'id', order: 'asc'}])
             .unique(['name'])
             .index('idx_Desc', [{name: 'desc', order: 'asc'}])
             .foreignKey({
               'name': 'fk_DeptId',
               'local': 'deptId',
               'remote': 'Dept.id',
               'action': 'restrict',
               'timing': 'immediate'
             });
  var q3 = db.setVersion(2);

  tx.append([q1, q2, q3]);
  return tx.commit();
}

function upgradeDb() {
  return db.alterTable('Dept').addColumn('desc', 'String').commit();
}

openDatabase().then(function() {
  // Real work starts here.
});

  </pre>
  <p>Once the database is opened, queries can be performed.</p>
  <pre class="example highlight">
var d = db.table('Dept');

function insertData() {
  var deptData = [
    {'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
    {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
    {'id': 'NADA', 'name': 'Non existing'},
    {'id': 'L', 'name': 'Leadership'}
  ];
  return db.insert().into(d).values(deptData).commit();
}

function updateData() {
  return db.update(d).set(d.desc, 'Master minds').where(d.id.eq('L')).commit();
}

function deleteData() {
  return db.delete().from(d).where(d.id.eq('NADA')).commit();
}

function selectData() {
  return db.select().from(d).commit();
}

insertData().then(function() {
  return updateData();
}).then(function() {
  return deleteData() {
}).then(function() {
  return selectData() {
}).then(function(rows) {
  // Expected returns:
  // [{'id': 'HR', 'name': 'Human Resources', 'desc': 'Rock stars'},
  //  {'id': 'ENG', 'name': 'Engineering', 'desc': 'Hard workers'},
  //  {'id': 'L', 'name': 'Leadership', 'desc': 'Master minds'}]
  console.log(rows);
});

  </pre>
</section>

    <section id="conformance"></section>

<section>
  <h2>Constructs</h2>
<section>
  <h2>Database</h2>
  <p>A database's origin is the same as the origin of the document or worker.
  Each origin has an associated set of database.</p>

  <p class="note">The database origin is not affected by changes to
  <code>document.domain</code>.</p>

  <p>Each origin has an associated set of databases. A database comprises one
  or more tables which hold the data stored in the database.</p>

  <p>Every database has a <em>name</em> which identifies it within a specific
  origin. The name must satisfy the Naming Rules, and stay constant for the
  lifetime of the database.</p>

  <p>Each database also has a version number for reference only. When a
  database is first created, its version is 0.</p>

  <p class="note">Implementations must support all names. If an implementation
  uses a storage mechanism which can't handle arbitrary database names, the
  implementation must use an escaping mechanism or something similar to map
  the provided name to a name that it can handle.</p>

  <p>Databases has a <em>delete pending</em> flag which is used during
  deletion. When a database is requested to be deleted the flag is set to true
  and all attempts at opening the database are stalled until database is
  deleted.</p>

  <p>The act of opening a database creates a <em>connection</em>. There may be
  multiple connections to a given database at any given time. Each connection
  has a <em>closePending</em> flag which initially is set to false.</p>

  <p>When a connection is initially created it is in opened state. The
  connection can be closed through several means. If the connection is garbage
  collected or execution context where the connection is created is destroyed
  (for example due to the user navigating away from that page), the connection
  is closed. The connection can also be closed explicitly using the steps for
  closing a database connection. When the connection is closed the
  closePending flag is always set to true if it hasn't already been. All
  uncommitted transactions will be cancelled if their associated connections
  are marked close pending.</p>

  <p>Every database contains zero or more <em>tables</em> to store data. A
  table contains zero or more <em>rows</em>. A row is also known as a record or
  a tuple, which represents a single structured data item in a table. A row
  consists zero or more <em>columns</em>, each with predefined data types.
  A database can also contain <em>indices</em>. An index is a data structure
  that enables fast lookup and/or enforces data integrity.</p>

  <p>Every database contains a <em>schema</em> that defines data types,
  referential integrity enforcement, and indices for the stored data.</p>

  <p>Users can create observers associated with a given database. Each
  observer consists a select query. When the results of that select query
  change, the observer will be triggered.</p>

  <p>The <code>IDatabaseConnection</code> interface represents a connection to
  a database.</p>
</section>

<section>
  <h2>Schema</h2>
  <p>The concept of relational database is to have a predefined layout of the
  data structures persisted, which is referred as schema throughout this
  document. A database schema consists of a list of table schemas. Each table
  schema has a list of column definitions, constraints, and index
  specifications for that table. The column definitions indicates how a row
  in that given table is structured.</p>

<section>
  <h2>Types</h2>
  <p>All columns in a table schema must be associated with a given type. Valid
  types of a column are defined in the following enum:</p>
  <dl title="enum ColumnType" class="idl">
    <dt>ArrayBuffer</dt>
    <dd>Represents the <code>ArrayBuffer</code> type in JavaScript</dd>
    <dt>Boolean</dt>
    <dd>Represents the <code>boolean</code> type in JavaScript</dd>
    <dt>Date</dt>
    <dd>Represents the <code>Date</code> type in JavaScript</dd>
    <dt>Number</dt>
    <dd>Represents the <code>Number</code> type in JavaScript</dd>
    <dt>String</dt>
    <dd>Represents the <code>string</code> type in JavaScript</dd>
    <dt>Object</dt>
    <dd>Represents the <code>Object</code> type in JavaScript</dd>
  </dl>
  <p><code>ArrayBuffer</code> and <code>Object</code> types are not
  <em>indexable</em>, which means columns of these types could not be used to
  create indices and predicates (except the <code>isNull()</code> and
  <code>isNotNull()</code> predicates).</p>
</section>

<section>
  <h2>Orders</h2>
  <p>There are two sorting orders defined in the following enum:</p>
  <dl title="enum Order" class="idl">
    <dt>asc</dt>
    <dd>Represents ascending sort order (Default)</dd>
    <dt>desc</dt>
    <dd>Represents descending sort order</dd>
  </dl>
  <p>Ascending sort order is the natural sort order, which means that if two
  fields are ordered as <code>a, b</code>, then <code>(a <= b) === true</code>.
  <code>ArrayBuffer</code> and <code>Object</code> types are not
  <em>indexable</em>, which implied they were not <em>comparable</em> and thus
  the orders have no effect for these two types.</p>
</section>

<section>
  <h2>Schema Definition JSON Format</h2>
  <p>Database schema can be defined using a single JSON object. The following
  example demonstrates how to create a database using such JSON object.</p>
  <pre class="example highlight">
// Create a database using predefined JSON schema.
var hrSchema = {
  'name': 'hr',
  'version': 2,
  'table': [
    {
      'name': 'Dept',
      'column': [
        {'name': 'id', 'type': 'String'},
        {'name': 'name', 'type': 'String'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id'}],
        'notNull': ['name']
      }
    },
    {
      'name': 'Emp',
      'column': [
        {'name': 'id', 'type': 'Number'},
        {'name': 'name', 'type': 'String'},
        {'name': 'deptId', 'type': 'String'},
        {'name': 'title', 'type': 'String'}
      ],
      'constraint': {
        'primaryKey': [{'name': 'id', 'order': 'desc'}],
        'foreignKey': [{
          'name': 'fk_DeptId',
          'local': 'deptId',
          'remote': 'Dept.id',
          'action': 'restrict',
          'timing': 'immediate'
        }],
        'unique': [{
          'name': 'uq_Name',
          'column': [{'name': 'name', 'order': 'desc'}]
        }],
        'notNull': ['id', 'name', 'deptId']
      },
      'index': [
        {
          'name': 'idx_Title',
          'column': [{'name': 'title', 'order': 'asc'}]
        }
      ]
    }
  ]
};

db.create(hrSchema).commit().then(function(instance) {
  // Instance is the connected instance.
}, function(e) {
  // e is the DOMError if any, e.g. AlreadyExists.
});

  </pre>
  <p>The schema JSON object has three fields:</p>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td>name</td><td>Name of the database</td></tr>
    <tr><td>version</td>
      <td>(Optional) Version of the database, for reference only</td>
    </tr>
    <tr><td>table</td><td>Array of table schemas</td></tr>
  </table>

  <section>
    <h2>Table Schema</h2>
    <p>The table schema is also a JSON object with the following fields:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the table</td></tr>
      <tr><td>column</td><td>Array of column definitions</td></tr>
      <tr><td>constraint</td><td>(Optional) Constraint definitions</td></tr>
      <tr><td>index</td><td>(Optional) Array of index definitions</td></tr>
    </table>

    <p>A column definition is a JSON object with two fields:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the column</td></tr>
      <tr><td>type</td><td>Type of the column</td></tr>
    </table>
  </section>

  <section>
    <h2>Index Definition</h2>
    <p>An index definition is a JSON object with the following fields:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the index</td></tr>
      <tr><td>column</td><td>Array of indexed column definitions</td></tr>
      <tr><td>type</td><td>Type of index</td></tr>
    </table>
    <p>Index type allows user to hint the implementation what this index is
    best to be used for. The implementation may or may not construct the index
    using corresponding algorithm. The index type is an enum:</p>
    <dl title="enum IndexType" class="idl">
      <dt>btree</dt><dd>B+ Tree index</dd>
      <dt>hash</dt><dd>Hash index</dd>
    </dl>

    <p>An indexed column definition is a JSON object with two fields:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the indexed column</td></tr>
      <tr><td>order</td><td>Sorting order of the column</td></tr>
    </table>
    <p>The name specified in the indexed column must exist in the same table
    defining this index, otherwise an <code>InvalidSchemaError</code> will be
    thrown. If the specified column is not indexable, an
    <code>InvalidSchemaError</code> will be thrown.</p>
    <p>If an index definition overlapped with implicit indices created by
    constraints (for example, create an index on the same column of the primary
    key), it will be up to the implementation to determine whether or not to
    create this index.</p>

    <p>An index can be keyed by one or more columns. All indices allow
    duplicate key values to exist. If unique indices are needed, please use
    the unique constraint to define them.</p>
  </section>

  <section>
    <h2>Constraint Definition</h2>
    <p>A constraint JSON object contains following fields, and all fields are
    optional:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>primaryKey</td><td>(Optional) Primary key definition</td></tr>
      <tr><td>foreignKey</td><td>(Optional) Foreign key definition</td></tr>
      <tr><td>unique</td>
          <td>(Optional) Array of unique constraint definitions</td>
      </tr>
      <tr><td>notNull</td>
          <td>(Optional) Array of column names that are not null</td>
      </tr>
    </table>
    <p>The name specified in the notNull array must exist in the same table
    defining this constraint, otherwise an <code>InvalidSchemaError</code>
    will be thrown. By default all columns accept null as valid value, unless
    the column is constrainted with notNull.</p>
  </section>

  <section>
    <h2>Unique Constraint Definition</h2>
    <p>Unique constraint is a specialized index that disallows duplicated keys.
    Its definition format is the same as index definition. If two or more
    columns are defined as keys, the combination of the columns forms the
    uniqueness.</p>
  </section>

  <section>
    <h2>Primary Key Definition</h2>
    <p>Each table can only have one primary key definition. The primary key
    will implicitly create an unique constraint and enforce it. A primary key
    definition can be an object or an array of indexed column definitions. When
    it is an object, it can have following fields:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Column name of the primary key</td></tr>
      <tr><td>order</td><td>(Optional) Sorting order, default to asc</td></tr>
      <tr><td>autoIncrement</td>
          <td>(Optional) <code>true</code> if this is auto-increment</td>
      </tr>
    </table>
    <p>When the autoIncrement field is specified, the specified column must be
    of type <code>Number</code>, and the order field must not be
    <code>desc</code>, otherwise an <code>InvalidSchemaError</code> will be
    thrown.</p>
  </section>

  <section>
    <h2>Foreign Key Definition</h2>
    <p>The foreign key definition is a JSON object with following fields:</p>
    <table class="parameters">
      <tr><th>Field</th><th>Description</th></tr>
      <tr><td>name</td><td>Name of the foreign key</td></tr>
      <tr><td>local</td><td>Referring column name</td></tr>
      <tr><td>remote</td><td>Referred column canonical name</td></tr>
      <tr>
        <td>action</td>
        <td>(Optional) Foreign key action, default: <code>restrict</code></td>
      </tr>
      <tr>
        <td>timing</td>
        <td>(Optional) Foreign key timing, default: <code>immediate</code></td>
      </tr>
    </table>
    <p>Foreign key actions are enum values as defined in the following:</p>
    <dl title="enum ForeignKeyAction" class="idl">
      <dt>restrict</dt>
      <dd>Any constraint violation results in cancelling the operation that
      violated the constraint.</dd>
      <dt>cascade</dt>
      <dd>Constraint violation results in modifying related tables as necessary
      to maintain data integrity.</dd>
    </dl>
    <p>Foreign key timings are enum values as defined below:</p>
    <dl title="enum ForeignKeyTiming" class="idl">
      <dt>deferrable</dt>
      <dd>The constraint is enforced right before a transaction is committed.
      The constraint can be violated by individual queries during the lifetime
      of the enclosing transaction, without any error being thrown.</dd>
      <dt>immediate</dt>
      <dd>The constraint is enforced during execution of each individual query.
      </dd>
    </dl>
  </section>

</section>


  <p>The following example demonstrates how to create a database schema.</p>
    <pre class="example highlight">
var tx = db.createTransaction('readwrite');
var q1 = db.createTable('Dept')
           .column(/* column_name */ 'id',
                   /* column_type */ 'String',
                   /* not_null */ true)
           .column('name', 'String', true)
           .primaryKey([{'name': 'id'}]);
tx.append(q1);

var q2 = db.createTable('Emp')
           .column('id', 'Number', true)
           .column('name', 'String', true)
           .column('deptId', 'String', true)
           .column('title', 'String')
           .primaryKey([{'name': 'id', 'order': 'asc'}])
           .unique(['name'])
           .index('idx_Desc', [{'name': 'desc', 'order': 'asc'}])
           .foreignKey({
             'name': 'fk_DeptId',
             'local': 'deptId',
             'remote': 'Dept.id',
             'action': 'restrict',
             'timing': 'immediate'
           });
q2.attachTo(tx);

tx.commit().then(...);

  </pre>
</section>

<section>
  <h2>Naming Rules</h2>
  <p>All names used in the relational database are case sensitive, and they
  must satisfy following rules:</p>
  <ul>
    <li>A name must pass the following check:
        <code>/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)</code>
    </li>
    <li>A name must not conflict with fields defined in
        <code>Object.prototype</code>
    </li>
  </ul>
</section>

<section>
  <h2>Errors</h2>
  <p>All errors in this specification are <code>DOMException</code> with the
  specified error type.</p>
  <table class="parameters">
    <tr><th>Field</th><th>Description</th></tr>
    <tr><td><code>ConstraintError</code></td>
        <td>Constraints are violated.</td>
    </tr>
    <tr><td><code>InvalidSchemaError</code></td>
        <td>Provided schema is invalid.</td>
    </tr>
  </table>
</section>

</section>


 </body>
</html>
